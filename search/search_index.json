{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Digital Notebook","text":"<p>Welcome to my personal space for learning, reflection, and growth. This digital notebook is where I organize my thoughts, document my study progress, and share insights on a variety of topics that capture my interest.</p> <p>I firmly believe that the process of writing and organizing knowledge is one of the most effective ways to learn. By articulating complex concepts and connecting different ideas, I can not only solidify my own understanding but also create a valuable resource for others who may be on a similar journey.</p> <p>Here, you will find a collection of my notes, summaries, and reflections on:</p> <ul> <li>Academic Courses: Detailed notes and insights from my studies at Zhejiang University.</li> <li>Self-Learning: Explorations into new technologies, programming languages, and personal projects.</li> <li>Research: Summaries and analyses of academic papers and my own research endeavors.</li> </ul> <p>I hope you find this notebook to be a source of inspiration and knowledge. Thank you for visiting, and I invite you to explore the various sections to see what I've been working on.</p>"},{"location":"ZJU%20CS%20COURSES/","title":"NOTES FOR ZJU CS COURSES","text":""},{"location":"ZJU%20CS%20COURSES/ADS/","title":"Advanced data structures and algorithms","text":"<p>Note</p> <p>This is a collection of notes for the course Advanced Data Structures and Algorithms at ZJU. The course is taught by Prof. Yue Chen. The notes are based on the course materials.</p> <p>!!!  </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eight/","title":"Dynamic Programming","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eight/#intro","title":"Intro","text":"<ul> <li>Fibonacci Numbers <p>The problem is, normal recursion will calculate the same subproblem multiple times, which is not efficient. DP solution: LessCss<pre><code>   int  Fibonacci ( int N ) \n   {   int  i, Last, NextToLast, Answer; \n       if ( N &lt;= 1 )  return  1; \n       Last = NextToLast = 1;    /* F(0) = F(1) = 1 */\n       for ( i = 2; i &lt;= N; i++ ) { \n           Answer = Last + NextToLast;   /* F(i) = F(i-1) + F(i-2) */\n           NextToLast = Last; Last = Answer;  /* update F(i-1) and F(i-2) */\n       }  /* end-for */\n       return  Answer; \n   }\n</code></pre></p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eight/#ordering-matrix-multiplications","title":"Ordering Matrix Multiplications","text":"<ul> <li>Problem:   <p>Given a sequence of matrices to be multiplied, determine the order in which to carry out the multiplications so as to minimize the number of  multiplications.  </p> </li> <li> <p>Solution:  </p> <p>If we have \\(n\\) matrices, \\(b_n=\\sum_{i=1}^{n-1}b_ib_{n-i}, where b_n=\\text{different way to compute the sequence of n matrices}\\), and if we  do normal iteration to deal with this problem, the time complexity will be \\(O(\\frac{4^n}{n\\sqrt{n}})\\) </p> </li> <li> <p>DP solution: LessCss<pre><code>    void OptMatrix( const long r[ ], int N, TwoDimArray M ) \n    {   int  i, j, k, L; \n        long  ThisM; \n        for( i = 1; i &lt;= N; i++ )   M[ i ][ i ] = 0; \n        for( k = 1; k &lt; N; k++ ) /* k = j - i */ \n            for( i = 1; i &lt;= N - k; i++ ) { /* For each position */ \n        j = i + k;    M[ i ][ j ] = Infinity; \n        for( L = i; L &lt; j; L++ ) { \n            ThisM = M[ i ][ L ] + M[ L + 1 ][ j ] \n                + r[ i - 1 ] * r[ L ] * r[ j ]; \n            if ( ThisM &lt; M[ i ][ j ] )  /* Update min */ \n            M[ i ][ j ] = ThisM; \n        }  /* end for-L */\n            }  /* end for-Left */\n    }\n</code></pre> The time conplexity is \\(O(N^3)\\) </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eight/#optimal-binary-search-tree","title":"Optimal Binary Search Tree","text":"<p>Note</p> <p> Ultilize the recursive essence of a tree </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eight/#all-pairs-shortest-path","title":"All-Pairs Shortest Path","text":"<ul> <li> <p>Problem:  </p> <p>For all pairs of vi and vj ( i \uf0b9 j ), find the shortest path between.</p> </li> <li> <p>Solution:   </p> <p>Single-source algorithm-&gt; \\(O(|V|^3)\\) </p> </li> <li> <p>A more clever DP when coping dense graphs\uff1a  \u3001 LessCss<pre><code>   /* A[ ] contains the adjacency matrix with A[ i ][ i ] = 0 */ \n   /* D[ ] contains the values of the shortest path */ \n   /* N is the number of vertices */ \n   /* A negative cycle exists iff D[ i ][ i ] &lt; 0 */ \n   void AllPairs( TwoDimArray A, TwoDimArray D, int N ) \n   {   int  i, j, k; \n       for ( i = 0; i &lt; N; i++ )  /* Initialize D */ \n            for( j = 0; j &lt; N; j++ )\n     D[ i ][ j ] = A[ i ][ j ]; \n       for( k = 0; k &lt; N; k++ )  /* add one vertex k into the path */\n            for( i = 0; i &lt; N; i++ ) \n     for( j = 0; j &lt; N; j++ ) \n        if( D[ i ][ k ] + D[ k ][ j ] &lt; D[ i ][ j ] ) \n        /* Update shortest path */ \n         D[ i ][ j ] = D[ i ][ k ] + D[ k ][ j ]; \n   }\n</code></pre> Reduce the time of sorting, unlike djikstra </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eight/#conclusion","title":"Conclusion","text":"<ul> <li>DP:  </li> </ul> <p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eleven/","title":"Approximation","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eleven/#definition","title":"Definition","text":"<ul> <li>Approximation Algorithms <p>Dealing with HARD problems When we encounter NP-complete problems, even a solution with \\(O(2^n)\\) is acceptable with a relative small \\(N\\) Yet mostly, we find near-optimal solutions in polynomial time. -&gt;   </p> </li> <li>Approximation Ratio <p>an algorithm has an approximation ratio of \\(\\rho (n)\\) if for any input size \\(n\\), the cost of the appeoximation solution \\(C^*\\) satifies: \\(max(\\frac{C}{C^*}, \\frac{C^*}{C}) \\leq \\rho (n)\\) </p> </li> <li>Approximation Scheme <ul> <li>PTAS: Polynomial-Time Approximation Scheme, satifies time complexity of \\(O(n^{2/\\epsilon})\\) </li> <li>FPTAS: Fully Polynomial-Time Approximation Scheme, satifies time complexity of \\(O((1/\\epsilon)^2 n^3)\\) </li> </ul> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eleven/#bin-packing","title":"Bin Packing","text":"<ul> <li>Problem: Given N items of sizes  \\(S_1,S_2,\\dots ,S_n\\) , such that \\(0 &lt; Si &lt;= 1\\) for all \\(1 &lt;= i &lt;= N\\). Pack these items in the fewest number of bins, each of which has unit capacity.  </li> </ul> Next FitFirst FitBest Fit <p>Note</p> <p> </p> <p>Proof: Quite simple, group every two of the next-fit bins, add their content together, the result must be larger than a single bin. If the amount of bins is at least \\(2M\\), the whole content will be over \\(M\\)(when the capacity is 1), which is impossible.</p> <p>Note</p> <p> </p> <p>Note</p> <p> </p> <p>Beware</p> <ul> <li>There is a big problem. Every step is irreversible, therefore the algorithms are limited. Off-line algorithms need to be taken into consideration.     </li> </ul> <p>Note</p> <p> </p> Off-line Algorithms <p>Note</p> <p> </p> <ul> <li>The sequence of the items is important. If all the small ones are arranged at first, there will be no space for the large ones to combine small ones. Therefore, all the larger items should be arranged at first.  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eleven/#the-knapsack-problem","title":"The Knapsack Problem","text":"<ul> <li>Problem: A knapsack with a capacity \\(M\\) is to be packed. Given N items.  Each item  \\(i\\)  has a weight  \\(w_i\\)  and a profit  \\(p_i\\) .    </li> <li>0-1 version: each item can be packed at most once, and connot be divided.   </li> </ul> <p>Proof</p> <p> </p> <ul> <li>Dynamic Programming:   </li> </ul> <p>Tip</p> <p> </p> <p>The undefined variable \\(p\\) is a big problem, if \\(\\sum P\\) gets too large, things might be out of control. Therefore, round all profit values up to lie in a smaller range.  </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eleven/#the-k-center-problem","title":"The K-center Problem","text":"<p>Qustion</p> <p> </p> <ul> <li> <p>Greedy Solution:  </p> <p>Put the first center at the best possible location for a single center, then keep adding centers , with each center reducing the largest covering radius locally. Yet obviously, it can be arbitrary bad. When \\(K=2\\), and there are two groups, huge distance between, and no distance within, boom!  </p> </li> <li> <p>Greedy Solution Enhanced:  </p> <p>What if we already knows a boundary in advance? What if we know or assume that \\(r(C^*) \\leq r\\), where \\(C^*\\) is the optimal solution set? Let's focused on the number \\(2r\\), if we can find a set of sites that the distance between them is larger than \\(2r\\), then even if we put a center in the middle, the covering radius will still be larger than \\(r\\).</p> </li> </ul> LessCss<pre><code>   Centers  Greedy-2r ( Sites S[ ], int n, int K, double r )\n   {   Sites  S\u2019[ ] = S[ ]; /* S\u2019 is the set of the remaining sites */\n       Centers  C[ ] = $\\emptyset$;\n       while ( S\u2019[ ] != $\\emptyset$) {\n           Select any s from S\u2019 and add it to C;\n           Delete all s\u2019 from S\u2019 that are at dist(s\u2019, s) \uf0a3 2r;\n       } /* end-while */\n       if ( |C| \\leqK ) return C;\n       else ERROR(No set of K centers with covering radius at most r);\n   }  \n</code></pre> <ul> <li> <p>Therom:  </p> <p>Suppose the algorithm selects more than K centers, the covering radius is \\(r(C*) &gt; r\\).   The algorithm returns a set C of K centers such that \\(r(C) \\leq 2r(C*)\\) where C* is an optimal set of K centers.  </p> </li> <li> <p>Greedy Enhanced with Approximation Ratio of 2:  </p> </li> </ul> Algorithm Demonstrationseoducode <p>Algorithm Demonstration</p> <p> </p> LessCss<pre><code>    Centers  Greedy-Kcenter ( Sites S[ ], int n, int K )\n    {   Centers  C[ ] = $\\emptyset$;\n        Select any s from S and add it to C;\n        while ( |C| &lt; K ) {\n            Select s from S with maximum dist(s, C);\n            Add s it to C;\n        } /* end-while */\n        return C;\n    } \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Eleven/#final-comclusion","title":"Final Comclusion","text":"<p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fifteen/","title":"External Sorting","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fifteen/#intro","title":"Intro","text":"<ul> <li> <p>Why can't we simply do quicksort on a disk?  </p> <p>Device dependent, slow disk To simplify, we can assume that the disk is a tape, thus can only be accessed sequentially.  </p> </li> <li> <p>Purpose:   </p> <p>Reduction of the number of passes Run merging Buffer handling for parallel operation Run generation  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fifteen/#pass-reduction","title":"Pass Reduction","text":"<ul> <li> <p>k-way merge:  </p> <p>Yet, requires 2k tapes Then, how to reduce the number of tapes?    </p> </li> <li> <p>Polyphase merge:  </p> <p>For a k-way merge, \\(F_N^k=F_{N-1}^k+\\dots+F_{N-k}^k\\), where \\(F_M^k=0 (0\\leq M\\leq k-2), F_{k-1}^k=1\\) Only k+1 tapes only What if the initial number of rins is not a Fibonacci number? Let the processor runs a few dummy runs(add dummy runs to the end of the tape)  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fifteen/#buffer-handling","title":"Buffer Handling","text":"<ul> <li> <p>Buffer:</p> <p>In order to keep the internal buffer running, we need to carefully arrange the buffer size.   for a k-way merge, when the input buffer perform sorting(merging), the result shall be stored in the output buffer. If the output buffer is only one block, then the merging process shall be stalled until the output buffer finish writing the data to disk. Therefore, output buffer should be at least 2 blocks. Thus, after the merging process is over, if there are only k buffers, to continue the process, we need to wait for the input buffer to read the data from disk. Therefore, the input buffer should be at least 2k blocks.  </p> </li> <li> <p>Problems:  </p> <p>Beyond a certain k value, the I\\O time would actually increase despite the decrease in the number of passes being made.  The optimal value for k clearly depends on disk parameters and the amount of internal memory available for buffers.  </p> </li> <li> <p>How to reduce the number of merges:  </p> <p>During each merge, one item is calculated one time. To reduce the overall workload, we shall decrease the amoun of merges to prevent multiple calculations for each item(runs). Therefore, using a min heap is a good idea. Compare the input with the item popped previously. If the input is larger, then the input is pushed into the heap. Otherwise, the input is written to the internal memory, waiting for the current min heap to be empty. Then it can lead another run. During this process, \\(L_{avg}=2M\\) Powerful when input is often nearly sorted for external sorting.( Because the runs can be really large)    </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fifteen/#minimizing-merging-time","title":"Minimizing merging time","text":"<ul> <li>Huffman Tree: As I have said, some runs might be merged several times. Therefore, try to let the smallest runs to be merged most of the time. Sound familiar, a Huffman Tree.   </li> </ul> <p>Huffman Tree</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Five/","title":"Binomial Queue","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Five/#structure","title":"Structure","text":"<ul> <li>Definition:   <p>A binomial queue is not a heap-ordered tree, but rather a collection of heap-ordered trees, known as a forest.  Each heap-ordered tree is a binomial tree. A priority queue of any size can be uniquely represented by a collection of binomial trees.  </p> </li> </ul> <p>Example</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Five/#operations","title":"Operations","text":"<ul> <li> <p>Findmin:  </p> <p>The minimum key is in one of the roots. There are at most \\(\\lceil log_2N \\rceil\\) roots, hence the time complexity is \\(O(logN)\\).(Can be stored and updated in constant time)  </p> </li> <li> <p>Merge:  </p> <p>Must keep the trees in the binomial queue sorted by height. \\(T_p=O(logN)\\) </p> </li> <li> <p>Insert:  </p> <p>If the smallest nonexistent binomial tree is Bi , then \\(T_p=Const\u00b7(i+1)\\). Performing N Inserts on an initially empty binomial queue will take O(N) worst-case time.  Hence the average time is constant.  </p> </li> <li> <p>DeleteMin:  </p> </li> </ul> <p>illustration</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Five/#implementation","title":"Implementation","text":"typestructMergeDeleteMin LessCss<pre><code>   typedef struct BinNode *Position;\n   typedef struct Collection *BinQueue;\n   typedef struct BinNode *BinTree;  /* missing from p.176 */\n\n   struct BinNode \n   { \n    ElementType     Element;\n    Position        LeftChild;\n    Position        NextSibling;\n   } ;\n\n   struct Collection \n   { \n    int         CurrentSize;  /* total number of nodes */\n    BinTree TheTrees[ MaxTrees ];\n   } ;  \n</code></pre> LessCss<pre><code>   BinTree\n   CombineTrees( BinTree T1, BinTree T2 )\n   {  /* merge equal-sized T1 and T2 */\n    if ( T1-&gt;Element &gt; T2-&gt;Element )\n        /* attach the larger one to the smaller one */\n        return CombineTrees( T2, T1 );\n    /* insert T2 to the front of the children list of T1 */\n    T2-&gt;NextSibling = T1-&gt;LeftChild;\n    T1-&gt;LeftChild = T2;\n    return T1;\n   }\n   BinQueue  Merge( BinQueue H1, BinQueue H2 )\n   {    BinTree T1, T2, Carry = NULL;   \n    int i, j;\n    if ( H1-&gt;CurrentSize + H2-&gt; CurrentSize &gt; Capacity )  ErrorMessage();\n    H1-&gt;CurrentSize += H2-&gt; CurrentSize;\n    for ( i=0, j=1; j&lt;= H1-&gt;CurrentSize; i++, j*=2 ) {\n        T1 = H1-&gt;TheTrees[i]; T2 = H2-&gt;TheTrees[i]; /*current trees */\n        switch( 4*!!Carry + 2*!!T2 + !!T1 ) { \n        case 0: /* 000 */\n        case 1: /* 001 */  break;   \n        case 2: /* 010 */  H1-&gt;TheTrees[i] = T2; H2-&gt;TheTrees[i] = NULL; break;\n        case 4: /* 100 */  H1-&gt;TheTrees[i] = Carry; Carry = NULL; break;\n        case 3: /* 011 */  Carry = CombineTrees( T1, T2 );\n                        H1-&gt;TheTrees[i] = H2-&gt;TheTrees[i] = NULL; break;\n        case 5: /* 101 */  Carry = CombineTrees( T1, Carry );\n                        H1-&gt;TheTrees[i] = NULL; break;\n        case 6: /* 110 */  Carry = CombineTrees( T2, Carry );\n                        H2-&gt;TheTrees[i] = NULL; break;\n        case 7: /* 111 */  H1-&gt;TheTrees[i] = Carry; \n                        Carry = CombineTrees( T1, T2 ); \n                        H2-&gt;TheTrees[i] = NULL; break;\n        } /* end switch */\n    } /* end for-loop */\n    return H1;\n   }\n</code></pre> LessCss<pre><code>   ElementType  DeleteMin( BinQueue H )\n   {    BinQueue DeletedQueue; \n    Position DeletedTree, OldRoot;\n    ElementType MinItem = Infinity;  /* the minimum item to be returned */  \n    int i, j, MinTree; /* MinTree is the index of the tree with the minimum item */\n\n    if ( IsEmpty( H ) )  {  PrintErrorMessage();  return \u2013Infinity; }\n\n    for ( i = 0; i &lt; MaxTrees; i++) {  /* Step 1: find the minimum item */\n        if( H-&gt;TheTrees[i] &amp;&amp; H-&gt;TheTrees[i]-&gt;Element &lt; MinItem ) { \n        MinItem = H-&gt;TheTrees[i]-&gt;Element;  MinTree = i;    } /* end if */\n    } /* end for-i-loop */\n    DeletedTree = H-&gt;TheTrees[ MinTree ];  \n    H-&gt;TheTrees[ MinTree ] = NULL;   /* Step 2: remove the MinTree from H =&gt; H\u2019 */ \n    OldRoot = DeletedTree;   /* Step 3.1: remove the root */ \n    DeletedTree = DeletedTree-&gt;LeftChild;   free(OldRoot);\n    DeletedQueue = Initialize();   /* Step 3.2: create H\u201d */ \n    DeletedQueue-&gt;CurrentSize = ( 1&lt;&lt;MinTree ) \u2013 1;  /* 2MinTree \u2013 1 */\n    for ( j = MinTree \u2013 1; j &gt;= 0; j \u2013 \u2013 ) {  \n        DeletedQueue-&gt;TheTrees[j] = DeletedTree;\n        DeletedTree = DeletedTree-&gt;NextSibling;\n        DeletedQueue-&gt;TheTrees[j]-&gt;NextSibling = NULL;\n    } /* end for-j-loop */\n    H-&gt;CurrentSize  \u2013 = DeletedQueue-&gt;CurrentSize + 1;\n    H = Merge( H, DeletedQueue ); /* Step 4: merge H\u2019 and H\u201d */ \n    return MinItem;\n   }\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Five/#proof","title":"Proof","text":"<ul> <li>Claim: A binomial queue of N elements can be built by N successive insertions in O(N) time.    </li> </ul> <p>Proof</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Four/","title":"Leftist Heaps and Skewed Heaps","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Four/#intro","title":"Intro","text":"<ul> <li> <p>Definition:  </p> <p>The null path length, \\(Npl(X)\\), of any node X is the length of the shortest path from X to a node without two children.  Define \\(Npl(NULL)=\u20131\\).   \\(Npl(X) = min { Npl(C) + 1 for all C as children of X }\\) The leftist heap property is that for every node X in the heap, the null path length of the left child is at least as large as that of the right child.  </p> </li> <li> <p>Theorem:  </p> <p>A leftist tree with r nodes on the rightmost path must have at least \\(2^r-1\\) nodes.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Four/#implementation","title":"Implementation","text":"typestructMergeIterative LessCss<pre><code>   struct TreeNode \n   { \n    ElementType     Element;\n    PriorityQueue       Left;\n    PriorityQueue       Right;\n    int         Npl;\n   } ;\n</code></pre> LessCss<pre><code>   PriorityQueue  Merge ( PriorityQueue H1, PriorityQueue H2 )\n   { \n    if ( H1 == NULL )   return H2;  \n    if ( H2 == NULL )   return H1;  \n    if ( H1-&gt;Element &lt; H2-&gt;Element )  return Merge1( H1, H2 );\n    else return Merge1( H2, H1 );\n   }\n   static PriorityQueue\n   Merge1( PriorityQueue H1, PriorityQueue H2 )\n   { \n    if ( H1-&gt;Left == NULL )     /* single node */\n        H1-&gt;Left = H2;  /* H1-&gt;Right is already NULL \n                    and H1-&gt;Npl is already 0 */\n    else {\n        H1-&gt;Right = Merge( H1-&gt;Right, H2 );     /* Step 1 &amp; 2 */\n        if ( H1-&gt;Left-&gt;Npl &lt; H1-&gt;Right-&gt;Npl )\n            SwapChildren( H1 ); /* Step 3 */\n        H1-&gt;Npl = H1-&gt;Right-&gt;Npl + 1;\n    } /* end else */\n    return H1;\n   }  \n</code></pre> <p>Note</p> <p> </p> <p>Easy to illustrate yet hard to implement </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Four/#skewed-heap","title":"Skewed Heap","text":"<ul> <li> <p>Definition:  </p> <p>Always swap the left and right children except that the largest of all the nodes on the right paths does not have its children swapped. \\(No Npl\\) Skew heaps have the advantage that no extra space is required to maintain path lengths and no tests are required to determine when to swap children. It is an open problem to determine precisely the expected right path length of both leftist and skew heaps.  </p> </li> <li> <p>Amortized Analysis:    </p> </li> </ul> <p>Proof</p> <p> Please bear in mind that the rightmost path theorem </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fourteen/","title":"Parallel Algorithm","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fourteen/#intro","title":"Intro","text":"<ul> <li>Parallelism:   <p>Machine Parallelism: Processor, Pipelining, Very-Long-Instruction-Word (VLIW), etc Parallel Algorithm: Today's topic  </p> </li> <li> <p>Discription:  </p> <p>PRAM: Parallel Random Access Machine WD: Work Depth Model    </p> </li> <li> <p>PRAM:  </p> <p>multi processors, shared memory, parallel read/write, concurrent execution, etc.  </p> </li> <li> <p>Avoid Conflicts:  </p> <p>EREW: Exclusive Read Exclusive Write CREW: Concurrent Read Exclusive Write CRCW: Concurrent Read Concurrent Write, three rules arbitrary, common(when trying to write the same value), priority(P with the smallest number)  </p> </li> <li> <p>Example:</p> </li> </ul> IllustrationSeudo Code <p> </p> <p>LessCss<pre><code>for P_i ,  1 &lt;=i &lt;= n  pardo\n  B(0, i) := A( i )\n  for h = 1 to log n do\n    if i &lt;= n/pow(2,h)\n      B(h, i) := B(h-1, 2i-1) + B(h-1, 2i)\n    else stay idle\n  for i = 1: output B(log n, 1); for i &gt; 1: stay idle\n</code></pre> \\(T(N)=\\log N+2\\), because different i are send to different processors and executed simultaneously, therefore only h shall be taken into consideration. </p> <p>The prblems are obvious:  1. Does not reveal how the algorithm will run on PRAMs with different number of processors 2. Fully specifying the allocation of instructions to processors requires a level of detail which might be unnecessary  </p> <ul> <li>WD: Layer by layer LessCss<pre><code>   for Pi ,  1 &lt;= i &lt;= n  pardo\n      B(0, i) := A( i )\n   for h = 1 to log n \n       for Pi, 1 &lt;= i &lt;= n/pow(2,h)  pardo\n           B(h, i) := B(h-1, 2i-1) + B(h-1, 2i)\n   for i = 1 pardo\n      output  B(log n, 1)  \n</code></pre></li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fourteen/#measuring-the-performance-of-parallel-algorithms","title":"Measuring the Performance of Parallel Algorithms","text":"<p>Work Load: total number of operations: \\(W(N)\\) Worst Case Running Time: \\(T(N)\\) \\(P(n) = W(n)/T(n)\\) processors and \\(T(n)\\) time (on a PRAM) \\(W(n)/p\\) time using any number of \\(p \u2264 W(n)/T(n)\\) processors (on a PRAM) \\(O(W(n)/p + T(n))\\) time using any number of p processors (on a PRAM)   </p> <ul> <li>Let's take a look back to the previuos example pf WD.  </li> <li>Work Load:   <p>\\(W(n)=n+n/2+n/4+\\dots+n/2^k+1\\), where \\(k=\\log n\\) </p> </li> </ul> <p>WD-presentation Sufficiency Theorem</p> <p>An algorithm in the WD mode can be implemented by any \\(P(n)\\) processors within \\(O(W(n)/P(n) + T(n))\\) time, using the same concurrent-write convention as in the WD presentation.  </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fourteen/#prefix-computations","title":"Prefix Computations","text":"<p>Illustration</p> <p> </p> <ul> <li>Remember when constructing thew whole tree, construct step by step  </li> </ul> <p>LessCss<pre><code>   for Pi , 1 &lt;= i &lt;=n pardo\n     B(0, i) := A(i)\n   for h = 1 to log n\n     for i , 1 &lt;= i &lt;= n/2h pardo\n       B(h, i) := B(h - 1, 2i - 1) + B(h - 1, 2i)\n   for h = log n to 0\n     for i even, 1 &lt;= i &lt;= n/2h pardo\n       C(h, i) := C(h + 1, i/2)\n     for i = 1 pardo\n       C(h, 1) := B(h, 1)\n     for i odd, 3 &lt;= i &lt;= n/2h pardo\n       C(h, i) := C(h + 1, (i - 1)/2) + B(h, i)\n   for Pi , 1 &lt;= i &lt;= n pardo\n     Output C(0, i)  \n</code></pre> * \\(T(n)=O(\\log n)\\), \\(W(n)=O(n)\\) </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fourteen/#merging","title":"Merging","text":"<ul> <li>Merge two non-decreasing arrays \\(A(1), A(2), \u2026, A(n) and B(1), B(2),\\dots, B(m)\\) into another non-decreasing array \\(C(1), C(2),\\dots, C(n+m)\\) </li> <li>To solve this problem in parallel, we need a rank(acknowlege where to put it, thus not altering C)  </li> </ul> <p>Illustration</p> <p> </p> <ul> <li>It's OK to use binary search or serial ranking.\\, but they either increases workload or time consumed.  </li> <li>Parallel Ranking:  </li> </ul> step 1 <p>Tip</p> <p> </p> <p>Use BS in the first search </p> step 2 <p>Tip</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Fourteen/#maximum-finding","title":"Maximum Finding","text":"<ul> <li>Simple Solution: Replace \u201c+\u201d by \u201cmax\u201d in the summation algorithm \\(-&gt; T(n)=O(\\log n)\\), \\(W(n)=O(n)\\) </li> <li>or we can compare all pairs of elements in parallel, but how to deal with conflicts? LessCss<pre><code>    for Pi , 1 &lt;= i &lt;= n  pardo\n        B(i) := 0\n    for i and j, 1 &lt;=i, j &lt;=n  pardo\n        if ( (A(i) &lt; A(j)) || ((A(i) = A(j)) &amp;&amp; (i &lt; j)) )\n                B(i) = 1\n        else B(j) = 1\n    for Pi , 1 &lt;=i &lt;= n  pardo\n        if B(i) == 0\n           A(i) is a maximum in A  \n</code></pre></li> </ul> A Doubly-logarithmic Paradigm(Recursive) <p>Note</p> <p> </p> Partition by \\(h=\\log\\log n\\) <p>Note</p> <p> </p> <ul> <li>Then,here comes the question: Is it possible to have a \\(O(1)\\) time complexity?      </li> </ul> <p>Solution</p> <p> Theorem: The algorithm finds the maximum among n elements.  With very high probability it runs in O(1) time and O(n) work.  The probability of not finishing within this time and work complexity is \\(O(1/n^c)\\) for some positive constant c.</p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Nine/","title":"Greedy Algorithms","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Nine/#definition","title":"Definition","text":"<ul> <li> <p>Optimization Problems:  </p> <p>Given a set of constraints and an optimization function.  Solutions that satisfy the constrains are called feasible solutions.  A feasible solution for which the optimization function has the best possible value is called an optimal solution.(Local search is based on this principle)    </p> </li> <li> <p>Greedy Method:  </p> <p>Make the best decision at each stage, under some greedy criterion. (The typical difference between greedy algorithm and local search is that one is step based(build one output) and the other is result based(find the local optimal).  A decision made in one stage is not changed in a later stage, so each decision should assure feasibility.    </p> </li> </ul> <p>Note</p> <ul> <li>Greedy algorithm works only if the local optimum is equal to the global optimum.(even though most of the time, this is not the case, we use this to reduce time complexity)  </li> <li>Greedy algorithm does not guarantee optimal solutions.  However, it generally produces solutions that are very close in value (heuristics) to the optimal, and hence is intuitively appealing when finding the optimal solution takes too much time.</li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Nine/#activity-seclection-problem","title":"Activity Seclection Problem","text":"<p>Question</p> <p> </p> <ul> <li>How to ultilize the greedy algorithm to solve this problem?   <p>Select the interval which ends first (but not overlapping the already chosen intervals) -&gt; Resource become free as soon as possible(left the most)  </p> </li> </ul> <p>And for this specific problem, the greedy algorithm is optimal. </p> <p>Proof</p> <p> </p> <ul> <li>DP solutiom:   <p>\\(c_{1,j} = \\begin{cases} 1 &amp; \\text{if} j=1 \\\\ \\max{c_{1,j-1}, c_{1,k(j)}+1} &amp; \\text{if} j&gt;1} \\end{cases}\\) where \\(k(j)\\) is the largest index \\(i&lt;j\\) such that \\(f_i \\le s_j\\) However, if each activity has a weight, the greedy is not correct.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Nine/#elements-of-greedy-strategy","title":"Elements of Greedy Strategy","text":"<ul> <li>Cast the optimization problem as one in which we make a choice and are left with one subproblem to solve.    </li> <li>Prove that there is always an optimal solution to the original problem that makes the greedy choice, so that the greedy choice is always safe.  </li> <li>Demonstrate optimal substructure by showing that, having made the greedy choice, what remains is a subproblem with the property that if we combine an optimal solution to the subproblem with the greedy choice we have made, we arrive at an optimal solution to the original problem. \uff08recursively)    </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Nine/#huffman-codes","title":"Huffman Codes","text":"<ul> <li>Example:   <p>Suppose our text is a string of length 1000 that comprises the characters  a, u, x, and z.  Then it will take 8000 bits to store the string as 1000 one-byte characters. The size of the coded string can be reduced using variable-length codes, for example, a = 0, u = 110, x = 10, z  = 111.   </p> </li> </ul> <p>If all the characters occur with the same frequency, then there are not likely to be any savings.  </p> <ul> <li> <p>seodo code: LessCss<pre><code>   void Huffman ( PriorityQueue  heap[ ],  int  C )\n   {   consider the C characters as C single node binary trees,\n        and initialize them into a min heap;\n        for ( i = 1; i &lt; C; i++ ) { \n           create a new node;\n           /* be greedy here */\n           delete root from min heap and attach it to left_child of node;\n           delete root from min heap and attach it to right_child of node;\n           weight of node = sum of weights of its children;\n           /* weight of a tree = sum of the frequencies of its leaves */\n           insert node into min heap;\n      }\n   }\n</code></pre></p> </li> <li> <p>Correctness: !!! note \"Prove by contradiction**  </p> <p> Pretty same as the previous proofs, focused on one step </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/","title":"AVL, Splay Trees and Amortized Analysis","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#1-avl-tree","title":"1. AVL tree","text":"<p>Intro</p> <ul> <li>Target: Speed up searching(insertion &amp;&amp; deletion)</li> <li>Basic tool: <code>BST</code> </li> <li>Problem: Unbalanced tree:  Although \\(T_p = O(\\text{height})\\), but the height can be as bad as \\(O(N)\\) </li> </ul> <p>Normal <code>BST</code> can be skewed to a linked list, which is not good for searching at all, thus one has absolute no control over the height of the tree.      </p> <p> </p> <p>The height varies, hence the time complexity of searching is not guaranteed.</p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#11-definition","title":"1.1. Definition","text":"<ul> <li>An empty binary tree is height balanced.  If \\(T\\) is a nonempty binary tree with \\(T_L\\) and \\(T_R\\) as its left and right subtrees, then \\(T\\) is height balanced iff<ul> <li>\\(T_L\\) and \\(T_R\\) are height balanced</li> <li>\\(|h_L - h_R| \\leq 1\\), where  \\(h_L\\) and \\(h_R\\) are the heights of \\(T_L\\) and \\(T_R\\) , respectively.</li> </ul> </li> </ul> <p>Note</p> <p>Balance factor: \\(BF(node) = h_L - h_R\\) <p>In AVL tree, \\(BF(node) \\in \\{-1, 0, 1\\}\\) </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#rotation","title":"Rotation","text":"<p>Be Ware</p> <p>Since the tree was constructed through dynamic insertion, \\(BF\\) is updated bottom-up.  Every time a rotation complete, \\(BF\\) needs to be updated.</p> <ul> <li> <p>Single rotation:   \\(|BF(node)| &gt; 1\\)</p> <ul> <li>LL rotation: <ul> <li>Target: \\(BF(node)=2\\) </li> <li>Condition: \\(BF(node-&gt;left) = 1\\) </li> <li>Operation: <ul> <li>Step 1: \\(node-&gt;left\\) becomes the new root</li> <li>Step 2: \\(node\\) becomes the right child of the new root</li> <li>Step 3: \\(node-&gt;left\\)'s right child becomes the left child of \\(node\\)</li> </ul> </li> </ul> </li> <li>Right rotation: <ul> <li>Target: \\(BF(node) = -2\\) </li> <li>Condition: \\(BF(node-&gt;right) = -1\\) </li> <li>Operation: <ul> <li>Step 1: \\(node-&gt;right\\) becomes the new root</li> <li>Step 2: \\(node\\) becomes the left child of the new root</li> <li>Step 3: \\(node-&gt;right\\)'s left child becomes the right child of \\(node\\) </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Double rotation: \\(|BF(node)| &gt; 1\\)</p> <ul> <li>LR rotation: <ul> <li>Target: \\(BF(node) = 2\\) </li> <li>Condition: \\(BF(node-&gt;left) = -1\\) </li> <li>Operation: <ul> <li>Step 1: \\(node-&gt;left\\)'s right child becomes the new root</li> <li>Step 2: \\(node-&gt;left\\)'s right child's left child becomes the right child of \\(node-&gt;left\\)</li> <li>Step 3: \\(node-&gt;left\\)'s right child's right child becomes the left child of \\(node\\)</li> </ul> </li> </ul> </li> <li>RL rotation: <ul> <li>Target: \\(BF(node) = -2\\) </li> <li>Condition: \\(BF(node-&gt;right) = 1\\) </li> <li>Operation: <ul> <li>Step 1: \\(node-&gt;right\\)'s left child becomes the new root</li> <li>Step 2: \\(node-&gt;right\\)'s left child's right child becomes the left child of \\(node-&gt;right\\)</li> <li>Step 3: \\(node-&gt;right\\)'s left child's left child becomes the right child of \\(node\\) </li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>While construct</p> <p>Double rotation is a combination of two single rotations. LR: left rotation on the left child, then right rotation on the root. RL: right rotation on the right child, then left rotation on the root. </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#12-insert","title":"1.2. Insert","text":"<ul> <li>Step 1: Insert the node as in a normal BST</li> <li>Step 2: Update the balance factor of the ancestors of the inserted node</li> <li>Step 3: If the balance factor of any node is not in \\(\\{-1, 0, 1\\}\\), do the rotation</li> </ul> <p>\\(BF\\) update</p> <p>Considering the fact that \\(BF\\) is calculated by substracting the height of left tree and right tree, to make \\(BF\\) update more suitable for recusion, keep a height field instead.</p> Fetching HeightInsertionSingle RotateDouble Rotate C<pre><code>static int  \nHeight( Position P)  \n{  \n    if( P == NULL )  \n        return -1;  \n    else  \n        return P-&gt;Height;  \n}  \n</code></pre> C<pre><code>AvlTree\nInsert( ElementType X, AvlTree T )  \n{  \n    if( T == NULL )  \n    {  \n        T = malloc( sizeof( struct AvlNode ) );  \n        if( T == NULL )  \n            FatalError( \"Out of space!!!\" );  \n        else  \n        {  \n            T-&gt;Element = X; T-&gt;Height = 0;  \n            T-&gt;Left = T-&gt;Right = NULL;  \n        }  \n    }  \n    else if( X &lt; T-&gt;Element )  \n    {  \n        T-&gt;Left = Insert( X, T-&gt;Left );  \n        if( Height( T-&gt;Left ) - Height( T-&gt;Right ) == 2 )  \n            if( X &lt; T-&gt;Left-&gt;Element )  \n                T = SingleRotateWithLeft( T );  \n            else  \n                T = DoubleRotateWithLeft( T );  \n    }  \n    else if( X &gt; T-&gt;Element )  \n    {  \n        T-&gt;Right = Insert( X, T-&gt;Right );  \n        if( Height( T-&gt;Right ) - Height( T-&gt;Left ) == 2 )  \n            if( X &gt; T-&gt;Right-&gt;Element )  \n                T = SingleRotateWithRight( T );  \n            else  \n                T = DoubleRotateWithRight( T );  \n    }  \n    T-&gt;Height = Max( Height( T-&gt;Left ), Height( T-&gt;Right ) ) + 1;  \n    return T;  \n}  \n</code></pre> C<pre><code>static Position\nSingleRotateWithLeft( Position K2 )  \n{  \n    Position K1;  \n\n    K1 = K2-&gt;Left;  \n    K2-&gt;Left = K1-&gt;Right;  \n    K1-&gt;Right = K2;  \n\n    K2-&gt;Height = Max( Height( K2-&gt;Left ), Height( K2-&gt;Right ) ) + 1;  \n    K1-&gt;Height = Max( Height( K1-&gt;Left ), K2-&gt;Height ) + 1;  \n\n    return K1;  \n}  \n</code></pre> C<pre><code>static Position\nDoubleRotateWithLeft( Position K3 )  \n{  \n    K3-&gt;Left = SingleRotateWithRight( K3-&gt;Left );  \n\n    return SingleRotateWithLeft( K3 );  \n}  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#13-height-of-avl-tree","title":"1.3. Height of AVL tree","text":"<ul> <li>Theorem: The height of an AVL tree storing \\(N\\) nodes is \\(O(\\ln N)\\)</li> </ul> <p>Proof</p> <p>\\(n(h)\\): the number of nodes in an AVL tree of height \\(h\\) </p> <ul> <li>Iteration: \\(n(h) = 1 + n(h-1) + n(h-2)\\)<ul> <li>Proof: <ul> <li>Fibonacci: \\(F(N) = F(N-1) + F(N-2)\\)</li> <li>\\(F(N) \\approx \\frac{1}{\\sqrt{5}} \\left( \\frac{1 + \\sqrt{5}}{2} \\right)^N\\)</li> <li>\\(n(h) = F_{h+3}-1\\)</li> </ul> </li> </ul> </li> <li>Conclusion: \\(h = O(\\ln N)\\)</li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#splay-trees","title":"Splay Trees","text":"<ul> <li>Definition:   <p>Any M consecutive tree operations starting from an empty tree take at most \\(O(MlogN)\\) time.  </p> </li> </ul> <p>illustration</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_One/#amortized-analysis","title":"Amortized Analysis","text":"<ul> <li>Aggregate analysis:   <p>Basically , worst case average  </p> </li> <li>Accounting method:   <p>When an operation\u2019s amortized cost \\(c_i^'\\) exceeds its actual cost  \\(c_i\\), we assign the difference to specific objects in the data structure as credit. Credit can help pay for later operations whose amortized cost is less than their actual cost.   </p> </li> <li>Potential method:   <p>The potential method is a way to determine the amortized cost of an operation \\(c_i^' = c_i + \\Phi(D_i) - \\Phi(D_{i-1})\\) \\(\\sum_{i=1}^{n}c_i^' = \\sum_{i=1}^{n}c_i + \\Phi(D_n) - \\Phi(D_0)\\) The main purpose is to use \\(\\Phi(D_i)\\) to eliminate some unknown factors in the actual cost of the operation.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Seven/","title":"Divide and Conquer","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Seven/#closest-points-problem","title":"Closest Points Problem","text":"<ul> <li> <p>Problem:  </p> <p>Given N points in a plane.  Find the closest pair of points.  (If two points have the same position, then that pair is the closest with distance 0.)  </p> </li> <li> <p>Solution:  </p> </li> </ul> <p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Seven/#recursive-time-complexity-analysis","title":"Recursive Time Complexity Analysis","text":"<ul> <li>Substitution Method:   <p>Guess, then prove by induction  </p> </li> </ul> <p>Example</p> <p> </p> <ul> <li>Recursion-tree method:   <p>Draw the recursion tree, then sum the cost of each level.  </p> </li> </ul> <p>Example</p> <p> </p> <p>Thus, there is no need to draw the whole tree, just make a thorough guess and proove by substitution  </p> <ul> <li>Master Method:   </li> <li> <p>\\(T(N)=aT(N/b)+f(N)\\) </p> <p>If \\(f(N)=O(N^{\\log_b{a}-\\epsilon})\\), for \\epsilon&gt;0, then \\(T(N)=\\Theta(N^{\\log_b{a}})\\)  If \\(f(N)=\\Theta(N^{\\log_b{a}})\\), then \\(T(N)=\\Theta(N^{\\log_b{a}}\\log{N})\\) If \\(f(N)=\\Omega(N^{\\log_b{a}+\\epsilon})\\), for \\epsilon&gt;0, and \\(af(N/b)\\le kf(N)\\), for k&lt;1, thus N sufficiently large then \\(T(N)=\\Theta(f(N))\\) </p> </li> <li> <p>Another Form:  </p> <p>If \\(af(N/b)=Kf(N)\\), for K&lt;1, then \\(T(N)=\\Theta(f(N))\\) If \\(af(N/b)=Kf(N)\\), for K=1, then \\(T(N)=\\Theta(f(N)\\log{N})\\) If \\(af(N/b)=Kf(N)\\), for K&gt;1, then \\(T(N)=\\Theta(N^{\\log_b{a}})\\) </p> </li> <li> <p>Another Theorem:  </p> <p>the solution to the equation \\(T(N)=aT(N/b)+\\Theta(N^k\\log^p{N})\\) is \\(T(N)= \\begin{cases} O(N^k\\log^{p+1}{N}) &amp; \\text{if} k=\\log_b{a} \\\\ O(N^{\\log_b{a}}\\log{N}) &amp; \\text{if} k&lt;\\log_b{a} \\\\ O(N^k\\log^pN) &amp; \\text{if} k&gt;\\log_b{a} \\end{cases}\\) </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Six/","title":"Backtracking","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Six/#rationale-of-backtracking","title":"Rationale of Backtracking","text":"<ul> <li>Definition:   <p>A sure-fire way to find the answer to a problem is to make a list of all candidate answers, examine each, and following the examination of all or some of the candidates, declare the identified answer. Backtracking enables us to eliminate the explicit examination of a large subset of the candidates while still guaranteeing that the answer will be found if the algorithm is run to termination. The basic idea is that suppose we have a partial solution \\((x_1,\\dots, x_i)\\) where each \\(x_k \\in S_k\\) for  \\(1 \\leq k \\leq i &lt; n\\).   First we add  \\(x_{i+1} \\in S_{i+1}\\) and check if \\((x_1,\\dots, x_i, x_{i+1})\\) satisfies the constrains.  If the answer is \u201cyes\u201d we continue to add the next x, else we delete xi and backtrack to the previous partial solution \\((x_1,\\dots, x_{i-1})\\).    </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Six/#eight-queens","title":"Eight Queens","text":"Step One <p>Note</p> <p> </p> Step Two <p>Perform a depth-first search(oost-order traversal) to examine the paths </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Six/#the-turnpike-reconstruction-problem","title":"The Turnpike Reconstruction Problem","text":"<ul> <li>Problem:     <p>Given N points on the x-axis with coordinates \\(x_1 &lt; x_2 &lt;\\dots&lt; x_N\\). Assume that \\(x_1 = 0\\).  There are \\(N(N\u20131)/2\\) distances between every pair of points. Given \\(N(N\u20131)/2\\) distances.  Reconstruct a point set from the distances.   </p> </li> </ul> Solution Illustrationseodu code <p>Note</p> <p> </p> LessCss<pre><code>   bool Reconstruct ( DistType X[ ], DistSet D, int N, int left, int right )\n   { /* X[1]...X[left-1] and X[right+1]...X[N] are solved */\n       bool Found = false;\n       if ( Is_Empty( D ) )\n           return true; /* solved */\n       D_max = Find_Max( D );\n       /* option 1\uff1aX[right] = D_max */\n       /* check if |D_max-X[i]| \\in D is true for all X[i]\u2019s that have been solved */\n       OK = Check( D_max, N, left, right ); /* pruning */\n       if ( OK ) { /* add X[right] and update D */\n           X[right] = D_max;\n           for ( i=1; i&lt;left; i++ )  Delete( |X[right]-X[i]|, D);\n           for ( i=right+1; i&lt;=N; i++ )  Delete( |X[right]-X[i]|, D);\n           Found = Reconstruct ( X, D, N, left, right-1 );\n           if ( !Found ) { /* if does not work, undo */\n               for ( i=1; i&lt;left; i++ )  Insert( |X[right]-X[i]|, D);\n               for ( i=right+1; i&lt;=N; i++ )  Insert( |X[right]-X[i]|, D);\n           }\n       }\n       /* finish checking option 1 */  \n       if ( !Found ) { /* if option 1 does not work */\n               /* option 2: X[left] = X[N]-D_max */\n               OK = Check( X[N]-D_max, N, left, right );\n               if ( OK ) {\n                   X[left] = X[N] \u2013 D_max;\n                   for ( i=1; i&lt;left; i++ )  Delete( |X[left]-X[i]|, D);\n                   for ( i=right+1; i&lt;=N; i++ )  Delete( |X[left]-X[i]|, D);\n                   Found = Reconstruct (X, D, N, left+1, right );\n                   if ( !Found ) {\n                       for ( i=1; i&lt;left; i++ ) Insert( |X[left]-X[i]|, D);\n                       for ( i=right+1; i&lt;=N; i++ ) Insert( |X[left]-X[i]|, D);\n                   }\n               }\n               /* finish checking option 2 */\n           } /* finish checking all the options */\n\n           return Found;\n       }  \n</code></pre> Template LessCss<pre><code>   bool Backtracking ( int i )\n   {   Found = false;\n       if ( i &gt; N )\n           return true; /* solved with (x1, \u2026, xN) */\n       for ( each xi \\in Si ) { \n           /* check if satisfies the restriction R */\n           OK = Check((x1, \u2026, xi) , R ); /* pruning */\n           if ( OK ) {\n               Count xi in;\n               Found = Backtracking( i+1 );\n               if ( !Found )\n                   Undo( i ); /* recover to (x1, \u2026, xi-1) */\n           }\n           if ( Found ) break; \n       }\n       return Found;\n   }  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Six/#tic-tac-toe","title":"Tic-Tac-Toe","text":"<ul> <li>Minimax Strategy:   <p>Use an evaluation function to quantify the \"goodness\" of a position.  For example: \\(f(P)=W_{Computer}-W_{Human}\\) where \\(W_{Computer}\\) is the number of ways the computer can win and \\(W_{Human}\\) is the number of ways the human can win. The computer will choose the move that maximizes the evaluation function, while the human will choose the move that minimizes the evaluation function. \\(\\alpha-\\beta\\) pruning is a technique to reduce the number of nodes that need to be evaluated in the search tree, with \\(\\alpha\\) indicates that if the min stage has a value less than \\(\\alpha\\), the max stage will not choose it, hence the child of the smaller node in min stage can be pruned. And \\(\\beta\\) indicates that if the max stage has a value greater than \\(\\beta\\), the min stage will not choose it, hence the child of the larger node in max stage can be pruned. when both techniques are combined. In practice, it limits the searching to only \\(O(\\sqrt N)\\) nodes, where N is the size of the full game tree.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Ten/","title":"NP Problems","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Ten/#examples","title":"Examples","text":"<ul> <li>Euler circuit problem: Find a path that visits every edge exactly once.(\\(P=NP\\))  </li> <li>Hamiltonian circuit problem: Find a path that visits every vertex exactly once.(\\(NP\\))  </li> <li>Traveling salesman problem: Find the shortest path that visits every vertex exactly once.(\\(NP\\))  </li> <li>Single-source shortest path problem: Find the shortest path from a vertex to all other vertices.(\\(P\\))  </li> <li>Single-source unweighted longest path problem: Find the longest path from a vertex to all other vertices.(\\(NP\\))  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Ten/#easy-and-hard","title":"Easy and Hard","text":"<ul> <li>Easy: Polynomial time(the easiest: \\(O(N)\\), for we have to read the input) </li> </ul> <p>Loop(p), the p here is the loop detecting function if(P(f(p))==1): implies whether f(p) is a infinite loop function    </p> <ul> <li>Hard: undecidable problems    </li> <li>Turing Machine:   <p>Deterministic Turing machine: executes one instruction at each point each time, based on the current state and the symbol under the tape head. Non-deterministic Turing machine: free to choose its next step from a finite set, and clever enough to choose the solution-direct step. which can be simply indicated as NTM knows the answer at the very first, therefore it only needs to verify the answer.  </p> </li> <li>Hamilton cycle problem: to check whether it is a NP problem, we only need to assume that there is a solution, and ask ourselves: does this simple circuit include all the vertices? And this process can be done in \\(O(V)\\) time.     <p>However we need to realize that not all decidiable problems are NP. Try whether a graph does not have a Hamilton cycle.  </p> </li> <li>the basic relationship: \\(P \\leq NP\\) </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Ten/#np-class","title":"NP class","text":"<ul> <li>NP-Complete problem: an NP-complete problem has the property that any problem in NP can be polybomially reduced to it. (reduced is the proper definition, but I personally prefer the word \"transformed\") If we can solve an NPC,  all NP problems can be solved. (Personal understanding, NPC is a one way result, you can assume that every problem that can be transformed polynomially from NPC is NPC, yet that is not the case with \"to\")   </li> </ul> <p>Example</p> <p>Suppose we already knew the Hamilton cycle problem is NPC, prove the TSP problem is NPC too.  The graph has a hamilton cycle if and only if the complete graph generated from the previous graph has a TSP path with \\(K&lt;=\\sum W_{edge_i}\\), where \\(W_{edge_i}\\) is the weight of the edge in the original graph. </p> <ul> <li>SAT: the satisfiability problem, which is the first problem to be proved NPC. Describe the problem as follows:   <ul> <li>Given a boolean formula, is there a way to assign the boolean variables to make the formula true?  </li> </ul> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Ten/#a-formal-language-framework","title":"A Formal-Language Framework","text":"<ul> <li>Abstact Problem: A binary relation on a set \\(I\\) of problem instances and a set if \\(S\\) of problem solutions.   </li> </ul>  Formal Language TheryDecide and AcceptVerify and Certificate <p>Formal-language Theory</p> <p> </p> <p> Decide and Accept</p> <p> </p> <p>Verify and Certificate</p> <p> </p> <ul> <li>\\(co-NP\\): if the complement of a problem is in NP, then the problem is in \\(co-NP\\).  </li> <li>relationship: \\(P \\subseteq NP \\cap co-NP\\) </li> </ul> <p>Usage Example</p> The Precise Definition of NPCExample ProblemAnswer: Proof of NPAnswer: Proof of NPC <p>Note</p> <p> </p> <p>Note</p> <p> </p> <p>Note</p> <p> </p> <p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/","title":"Inverted File Index","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/#intro","title":"Intro","text":"<ul> <li> <p>Term-Document Incidence Matrix </p> <p>Too sparse for a matrix  </p> </li> <li> <p>Inverted File Index </p> <p>Index is a mechanism for locating a given term in a text. Inverted file contains a list of pointers (e.g. the number of a page) to all occurrences of that term in the text.  </p> </li> </ul> <p>Note</p> <p> </p> <ul> <li> <p>Word Stemming:  </p> <p>Process a word so that only its stem or root form is left. </p> </li> <li> <p>Stop Words:  </p> <p>Some words are so common that almost every document contains them, such as \u201ca\u201d \u201cthe\u201d \u201cit\u201d.  It is useless to index them.  They are called stop words.  We can eliminate them from the original documents.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/#distributed-indexing","title":"Distributed Indexing","text":"<ul> <li>Term-partitioned index:   <p>Seperate by alphabets  </p> </li> <li>Document-partitioned index:   <p>Seperate by file  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/#dynamic-indexing","title":"Dynamic Indexing","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/#compression","title":"Compression","text":"<p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/#thresholding","title":"Thresholding","text":"<p>Sort the query terms by their frequency in ascending order; search according to only some percentage of the original query terms  </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Three/#user-happiness","title":"User Happiness","text":"<p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/","title":"Local Search","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/#intro","title":"Intro","text":"<ul> <li>Solve problem approximately  </li> <li>aim at a local optimal</li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/#framework-of-local-search","title":"Framework of Local Search","text":"<ul> <li>Local:   <p>Define neighborhoods in the feasible set A local optimum is the best solution in a neighbourhood  </p> </li> <li>Search   <p>Start with a feasible solution and search a better one within the neighbourhood A local optimum is achieved if no improvement is possible  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/#neighbor-relation","title":"Neighbor Relation","text":"<ul> <li>\\(S ~ S'\\): \\(S'\\) is a neighbouring solution of \\(S\\)-&gt;\\(S'\\) can be obtained by a small modification of \\(S\\).  </li> <li>\\(N(S)\\): neighborhood of \\(S\\) -&gt; the set \\({S':S~S'}\\) <ul> <li>Famous implementation: Gradient Decent  </li> </ul> </li> </ul> The Vertex Cover Problem"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/#improvement","title":"Improvement","text":"<ul> <li> <p>The Metropolis Algorithm LessCss<pre><code>   Solution Type Metropolis(SolutionType S, double T)  \n   {  \n       SolutionType S' = RandomNeighbor(S);  \n       if (f(S') &lt; f(S))  \n           return S';  \n       else if (Random(0,1) &lt; exp((f(S) - f(S'))/T))  \n           return S';  \n       else  \n           return S;  \n   }  \n</code></pre></p> <p>But it might bounce back and forth between several solutions(therefore customize the temperature)  </p> </li> <li> <p>Simulated Annealing   </p> <ul> <li>\\(T\\) is a decreasing function of time  </li> <li>\\(T = T_0 \\times \\alpha^t\\) </li> </ul> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/#hopfield-neural-network","title":"Hopfield Neural Network","text":"<p>Problem Description</p> <p> </p> <ul> <li> <p>State-flipping Algorithm: LessCss<pre><code>    ConfigType State_flipping()  \n    {\n        Start from an arbitrary configuration S;\n        whie(!IsStable(S))\n        {\n            u=GetUnsatisfied(S);  \n            S[u] = -S[u];\n        }\n        return S;\n    }\n</code></pre></p> </li> <li> <p>Claim: The state-flipping algorithm terminates at a stable configuration after at most \\(W=\\sum_e|w_e|\\) iterations.  </p> </li> <li>Proof:   <p>Every time we flip a state, the \\(\\phi(S)=\\sum_{e is good}|w_e|\\) by at least 1, thus \\(\\phi(S)\\) is non-negative and bounded by \\(W\\).    </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Twelve/#maximum-cut-problem","title":"Maximum Cut Problem","text":"<p>Problem Description</p> <p> </p> <ul> <li>Claim: Let (A, B) be a local optimal partition and let (A, B) be a global optimal partition. Then \\(w(A, B) \\beq \\frac{2}{1}w(A^*, B^*)\\) </li> </ul> <p>Proof</p> <p> </p> <ul> <li> <p>Try to use the \"local optiaml partition\" as a tool.     </p> </li> <li> <p>Limited Executed Time:    </p> </li> </ul> Big-improvement-flipK-L heuristic <p>Note</p> <p> </p> <p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Two/","title":"Red-Black Trees and B+ Trees","text":""},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Two/#intro","title":"Intro","text":"<ul> <li>Definition:   <p>A red-black tree is a binary search tree that satisfies the following red-black properties: * Every node is either red or black. * The root is black. * Every leaf (NIL) is black. * If a node is red, then both its children are black. * For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Two/#black-height","title":"Black Height","text":"<ul> <li>Definition:   <p>The black-height of any node x, denoted by bh(x), is the number of black nodes on any simple path from x (x not included) down to a leaf.  bh(Tree) = bh(root). Proof: for any node x, \\(sizeof(X) \\geq 2^{bh(x)}-1\\), by inducting on the height of the tree, we can get the conclusion. \\(bh(Tree) \\geq h(Tree)/2\\) </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Two/#operations","title":"Operations","text":"InsertDelete <p>Note</p> <p> </p> <p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Two/#conclusion","title":"Conclusion","text":"<p>Tip</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ADS/Chapter_Two/#b-tree","title":"B+ Tree","text":"<ul> <li>Definition:   <p>A B+ tree of order M is a tree with the following structural properties: * The root is either a leaf or has between 2 and M children. * All nonleaf nodes (except the root) have between \\(\\lceil M/2 \\rceil\\) and M children. * All leaves are at the same depth. Assume each nonroot leaf also has between \\(\\lceil M/2 \\rceil\\) and M children.  </p> </li> </ul> <p>LessCss<pre><code>   Btree  Insert ( ElementType X,  Btree T ) \n   { \n    Search from root to leaf for X and find the proper leaf node;\n    Insert X;\n    while ( this node has M+1 keys ) {\n            split it into 2 nodes with (M+1)/2 and (M+1)/2 keys, respectively;\n            if (this node is the root)\n                create a new root with two children;\n            check its parent;\n    }\n   }   \n</code></pre> \\(Depth(M,N)=O(\\log_{\\lceil M/2 \\rceil}N)\\) </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/","title":"ALGORITHM IN GAMES","text":"<p>Note</p> <p>The course is given online by Prof. William from CMU</p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/","title":"Collision Detection","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#collision-detection","title":"Collision Detection","text":"<ul> <li>Collision detection is a fundamental problem in computer graphics and game development.  </li> <li>The problem is to determine whether two objects are intersecting.  </li> <li>for each pair of sprites, check wheher \\(p_1 \\cap p_2 \\eq \\emptyset -&gt;\\) No collision!!!  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#rect-collision-algorithm","title":"Rect Collision Algorithm","text":"<p> collidepoint: Python<pre><code>def collidepoint(self, x, y):  \n    return self.left &lt;= x &lt;= self.right and self.top &lt;= y &lt;= self.bottom  \n</code></pre></p> <p>Warning</p> <p>The test need to be bi-directional. </p> <p>colliderect: Python<pre><code>def colliderect(self, rect):  \n    return self.left &lt; rect.right and self.right &gt; rect.left and self.top &lt; rect.bottom and self.bottom &gt; rect.top  \n</code></pre> Problematic indeed: checks too frequently, move-through prolems  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#tyranny-of-numbers","title":"Tyranny of numbers","text":"<p>Note</p> <p>checking collisions for all pairs of objects is not feasible </p> <p>(\u5c31\u50cf\u65f6\u5e8f\u4e0b\u6cbf\u65f6\u539f\u4ef6\u7684delay)  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#solving-all-the-possible-problems","title":"Solving all the possible problems","text":"<ul> <li>need to look for objects that don't move, and that are allowed to go through other objects  </li> <li>distant objects can be ignored  </li> <li>objects that are not visible can be ignored(off-screen objects)  </li> <li>restricted locations  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#quadtreeand-other-sorting-methods","title":"Quadtree(and other sorting methods)","text":"<ul> <li>A tree data structure in which each internal node has exactly four children.   </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#quick-test","title":"Quick test","text":"<ul> <li>Circle/ Sphere test  don't use <code>sqrt</code> function, too ecpensive(Numerical Analysis)   </li> <li>Bounding Box(a better rectangle)   </li> <li>a better collision detection algorithm(don't use corners of the rec)   </li> <li>Separating Axis Theorem:  <ul> <li>if two convex shapes do not intersect, there exists a line such that the projection of the two shapes onto the line do not overlap.   </li> </ul> </li> <li>Capsule(semicircles: a bounding test for the rec,and a circle test for the circle)  </li> </ul> <p>Book Recommendation</p> <p>Game Programming: Algorithms and Techniques by Sanjay Madhaven </p> <ul> <li>Swept Sphere Algorithm(use math to determine whether two moving objects will collide dynamically) \\((B\\cdot B)t^2+2(A\\cdot B)t+A\\cdot A-(r_p+r_q)^2=0\\) </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Five/#resolve-collision","title":"Resolve Collision","text":"<ul> <li>Bounces  </li> <li>Elastic Collisions  find the touching point   </li> </ul> <p>\\(\\vec{v_1}=\\vec{v}-2\\vec{n}(\\vec{v} \\cdot \\vec{n})\\) </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/","title":"Navigation Algorithms","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#navigation","title":"Navigation","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#control","title":"Control","text":"<ul> <li>where control means AI  </li> <li>pay attention to \"State Machines\"  </li> <li>State Machines: a way of representing the state of an object and the transitions between those states  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#graph","title":"Graph","text":"<p>\\(Graph =Set(Vertices,Edges)\\) The relationship between mazes and graphs: How big shall each vertices be? How to approximate a line? * Bresenham's line algorithm * Linear interpolation * Orthognal steps  (Numerical Analysis)  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#navigation_1","title":"Navigation","text":"<p>single source, all destinations  * Generally so Sum(cost) is minimized * Classic Graph Search * Breath First Search: Unweighted edges * Dijkstra: weighted  * Bellman-Ford: wieghted with negative edges   all source, all destinations * Floyd * Johnson's Algorithm  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#bfs","title":"BFS","text":"<ul> <li>the point is to discover some destination cell simply look up in the dictionary is enough </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#early-exit","title":"Early Exit","text":"<p>Add a conditional choice to end the loop  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#obstacles","title":"Obstacles","text":"<p>Tip</p> <p>Obstacles shall not be listed as neighbours </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#dijkstra","title":"Dijkstra","text":"<ul> <li>use a minheap  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#heuristic","title":"Heuristic","text":"<p>Greedy+Heuristic function * A* Algorithm \\(F(n)=G(n)+H(n)\\) * G(n): the cost of the path from the start node to n * H(n): the heuristic function, the estimated cost from n to the goal * A* is optimal if H(n) is admissible  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#navmesh","title":"Navmesh","text":"<ul> <li> <p>A* at scale: takes too long  </p> </li> <li> <p>Navmesh: a mesh of polygons  Navigation in the mesh:  if the target is not in the same polygon as the agent, the agent will move to the edge of the polygon (use A* to determine which mesh to cross)and then move to the target.   </p> </li> </ul> <p>more benefit</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Four/#funnel-algorithm","title":"Funnel Algorithm","text":"<ul> <li>smoothing the ideal path  </li> <li>that is choosing the vertices of the polygon and find the shortest path  </li> <li>the funnel is the area that the agent can move in  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/","title":"Introduction","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#pygame","title":"Pygame","text":"<ul> <li>Wraps SDL  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#modules","title":"Modules","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#game-loop","title":"Game Loop","text":"<ul> <li> <ol> <li>Check for inputs  </li> </ol> </li> <li> <ol> <li>update states </li> </ol> </li> <li> <ol> <li>draw another frame base on the current situation  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#mvc","title":"MVC","text":"<ul> <li> <ol> <li>architecutal style for GUI  </li> </ol> </li> <li> <ol> <li>Model, View, Controller  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#model","title":"Model","text":"<ul> <li> <ol> <li>well-defined interface for data processing  </li> </ol> </li> <li> <ol> <li>database    </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#view","title":"View","text":"<ul> <li> <ol> <li>visualization  </li> </ol> </li> <li> <ol> <li>rendering  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#controller","title":"Controller","text":"<ul> <li> <ol> <li>user input  </li> </ol> </li> <li> <ol> <li>update model and view actions  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#object-oriented-models","title":"Object-Oriented Models","text":"<p>Tip</p> <ul> <li> <ol> <li>Object: instance of a class</li> </ol> </li> <li> <ol> <li>Class: blueprint for objects</li> </ol> </li> <li> <ol> <li>Inheritance: subclass inherits from superclass</li> </ol> </li> <li> <ol> <li>Polymorphism: subclass can override methods of superclass</li> </ol> </li> <li> <ol> <li>Encapsulation: data hiding   </li> </ol> </li> </ul> <ul> <li>use objects for items in my game  </li> <li>use classes to define objects</li> <li>each object knows its own state, and so is part of the model  </li> <li>each object can draw itself, so is part of the view  </li> </ul> <p>Tip</p> <ul> <li> <ol> <li>Model: has references to objects and calls their update methods</li> </ol> </li> <li> <ol> <li>View: draw()</li> </ol> </li> <li> <ol> <li>Controller: user input  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#graphics","title":"Graphics","text":"<ul> <li> <ol> <li>Engine: graphics algorithms embedded  </li> </ol> </li> <li> <ol> <li>Colors: RGB, Alpha  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#the-surface","title":"The Surface","text":"<ul> <li> <ol> <li>2D array of pixels,returned from display.set_mode()  </li> </ol> </li> </ul> <p>The difference between class and module</p> <p>Classes are blueprints that allow you to create instances with attributes and bound functionality. Classes support inheritance, metaclasses, and descriptors. Modules can't do any of this, modules are essentially singleton instances of an internal module class, and all their globals are attributes on the module instance. You can manipulate those attributes as needed (add, remove and update), but take into account that these still form the global namespace for all code defined in that module. </p> <ul> <li> <ol> <li>The display Surface is visible to the user  </li> </ol> </li> <li> <ol> <li>background surface is copyed to the display surface while rendering  </li> </ol> </li> <li> <ol> <li>get_at and set_at methods to access pixel values, set colors of it  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#draw-module","title":"Draw module","text":"<ul> <li>surface is a parameter  </li> <li>draw.rect(surface, color, rect)  </li> <li>draw.circle(surface, color, center, radius)</li> <li>draw.line(surface, color, start_pos, end_pos, width)</li> <li>draw.arc(surface, color, rect, start_angle, stop_angle, width) <code>surface.fill(color)</code>: to fill the entire function  </li> <li>draw.polygon(surface,color,points,width=1)  </li> <li>Rect object: <ul> <li> <ol> <li>x,y,width,height  </li> </ol> </li> </ul> </li> <li>Using rect with draw:  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_One/#pygame-images","title":"Pygame Images","text":"<ul> <li> <ol> <li>image formats: PNG, JPEG, BMP, GIF, etc  </li> </ol> </li> <li> <ol> <li>load image: image.load(filename) </li> </ol> </li> <li> <ol> <li>convert() method to convert image to the same format as the display surface</li> </ol> </li> <li> <ol> <li>blit() method to draw the image on the display surface</li> </ol> </li> <li> <ol> <li>Blit optimization: blit() is faster than draw(), graphics harware handles the entire BLIT  </li> </ol> </li> <li> <ol> <li>colorkey</li> <li>set_colorkey() method to set the transparent color</li> </ol> </li> <li> <ol> <li>surface transformation: scale, rotate, flip</li> <li>surface.transform.scale(surface, (width, height))</li> <li>surface.transform.rotate(surface, angle)</li> <li>surface.transform.flip(surface, xbool, ybool)  </li> </ol> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/","title":"Mazes Algorithms","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#mazes","title":"Mazes","text":"<ul> <li>Perfect mazes: no loops, has one and only one path between any two cells    </li> <li>Unicursal mazes: no branches, a single path from start to finish  </li> <li>Braid mazes: loops, but no dead ends  </li> <li>weave maze: passages go over and under each other  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#metrics","title":"Metrics","text":"<ul> <li>All neighboring cells will be either linked or unlinked  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#algorithms","title":"Algorithms","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#binary-treea-wall-carving-algorithm","title":"Binary Tree(a wall carving algorithm)","text":"<ul> <li>Cells on the East column are all linked to their North neighbor(\u53f3\u4fa7\u4e00\u6761\u7ebf)  </li> <li>Cells on the North row are all linked to their East neighbor(\u4e0a\u4fa7\u4e00\u6761\u7ebf) Except:   </li> <li>The North-East cell  a clear path from the bottom left to the top right No entry or exit, yet perfect   </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#sidewinder","title":"Sidewinder","text":"<ul> <li>a wall carving algorithm  </li> <li>Top rows: link cells together  </li> <li>Other rows: Add leftmost cell to the    top-row clear rows are longer, yet not linked cons are random, mostly blocked each row can be handled in parallel  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#aldous-broder","title":"Aldous-Broder","text":"<ul> <li>Random walk:  <ul> <li>Randomly choose a neighbor  </li> <li>If not visited, link and move  </li> <li>If visited, move</li> <li>Random walk until all cells are visited   take a long time to generate  </li> </ul> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#wilsons","title":"Wilson's","text":"<p> * in the beginning, its hard to find a random walk back to that starting point without looping * But the end is quick  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#recursive-backtracker","title":"Recursive Backtracker","text":"<p> few dead ends yet biased yet it is not memory-efficient (recursive calls)  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#solution-algorithm","title":"Solution algorithm","text":"<ul> <li>Wall follower:  <ul> <li>Always follow the right wall  </li> <li>If no right wall, turn right  </li> <li>If no right wall, turn left  </li> <li>If no right wall, turn around  </li> </ul> </li> <li>Dead-end filler  </li> <li>Recursive backtracker  </li> <li>Tr\u00e9maux's algorithm  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Three/#dijkstras-algorithm","title":"Dijkstra's algorithm","text":"<p>longest path: * pick a random cell for the root(A)     * run Dijkstra's algorithm on it (find the furthest from A, call it B)    * run Dijkstra's algorithm on B (find the furthest from B, call it C)   * \\(B-&gt;C\\) is the longest path   </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/","title":"Pygame","text":""},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/#fonts-and-text-renders","title":"Fonts and text renders","text":"<ul> <li>Pygame renders text to a surface with the font module  </li> <li>Font module can locate and load a font as a Font object How to render text: Python<pre><code>font = pygame.font.Font(None, 36)\ntext = font.render(\"Hello, World\", True, (255, 0, 0))\nscreen.blit(text, (200, 200))\n</code></pre> the font.render() method returns a surface with the text rendered on it <code>a_font.size()</code>: method returns the size of the text  , a turple of width and height <code>a_font.get_height()</code>: method returns the height of the font <code>a_font.get_linesize()</code>: method returns the height of a line of text <code>a_font.metrics</code>:returns a list with one turple per character in ttext  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/#spritesobject-oriented-models","title":"Sprites(Object-Oriented Models)","text":"<p>Python<pre><code>class MySprite(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.image = pygame.Surface((50, 50))\n        self.image.fill((255, 0, 0))\n        self.rect = self.image.get_rect()\n        self.rect.topleft = (100, 100)\n</code></pre> the usage of sprites: Python<pre><code>sprite = MySprite()\nsprite_group = pygame.sprite.Group()\nsprite_group.add(sprite)\nsprite_group.draw(screen)\n</code></pre> <code>sprite_group.draw(screen)</code>: method draws all the sprites in the group to the screen sprite operations with group: Python<pre><code>sprite_group.update()\nsprite_group.clear(screen, background)\nsprite_group.remove(sprite)\n</code></pre> <code>Group.clear(surface, background)</code>: clears the sprites from the screen <code>Group.draw(surface)</code>: draws the sprites to the screen  LayerUpdates class: Python<pre><code>class LayerUpdates(pygame.sprite.LayeredUpdates):\n    def __init__(self):\n        pygame.sprite.LayeredUpdates.__init__(self)\n        self.add(MySprite())\n</code></pre> a group within group DirtySprite class: Python<pre><code>class DirtySprite(pygame.sprite.DirtySprite):\n    def __init__(self):\n        pygame.sprite.DirtySprite.__init__(self)\n        self.image = pygame.Surface((50, 50))\n        self.image.fill((0, 255, 0))\n        self.rect = self.image.get_rect()\n        self.rect.topleft = (200, 200)\n</code></pre> <code>DirtySprite.dirty</code>: attribute to indicate whether the sprite needs to be updated <code>DirtySprite.dirty = 1</code>: set the sprite to be updated <code>DirtySprite.dirty = 0</code>: set the sprite not to be updated LayeredDirty class: Python<pre><code>class LayeredDirty(pygame.sprite.LayeredDirty):\n    def __init__(self):\n        pygame.sprite.LayeredDirty.__init__(self)\n        self.add(DirtySprite())\n</code></pre> Collision Detection:will be discussioned in chapter five  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/#animation","title":"Animation","text":"<p>Animation: a series of images displayed in rapid succession to create the illusion of movement  </p> <p>how to make shure that the animation is smooth?</p> <ol> <li>slow the game loop down to a consistent number  </li> <li>measure the time between frames and adjust the speed of the animation accordingly  </li> </ol> <p>Approach 1: Slowerloop a tick() method to control the speed of the game loop Python<pre><code>def tick(self):\n    self.clock.tick(30)\n</code></pre> Approach 2: Measure delta value: the time cost of the last frame(game loop) delta=clock.tick() it will return number of milliseconds  since last time</p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/#randomness","title":"Randomness","text":"<p>Randomness: a key element in games <code>random.randint(a, b)</code>: returns a random integer between a and b <code>random.choice(sequence)</code>: returns a random element from a sequence <code>random.shuffle(sequence)</code>: shuffles the sequence in place <code>random.seed()</code>: initializes the random number generator LCG: Linear Congruential Generator: a simple algorithm to generate random numbers \\(X_{n+1}=(aX_n+c)mod m\\) \\(ex: X_{n+1}=(1664525X_n+1013904223)mod 2^{32}\\) LCG has a specific period, and the period is the maximum number of random numbers that can be generated before the sequence repeats</p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/#prng-pseudo-random-number-generator","title":"PRNG: Pseudo-Random Number Generator","text":"<p>PRNG: a deterministic algorithm that generates a sequence of numbers that approximates the properties of random numbers a good PRNG should have a long period, be unpredictable, and have a uniform distribution  </p>"},{"location":"ZJU%20CS%20COURSES/ALGORITHM%20IN%20GAMES/Chapter_Two/#random-distributions","title":"Random distributions","text":"<p>Uniform distribution: each number has an equal chance of being selected Normal distribution: a bell-shaped curve with the mean at the center Asymmetric distribution: a distribution that is not symmetrical: Dropping the lowest roll, reroll the lowest  Critical Hit: a game mechanic that allows a player to deal extra damage How to construct a critical hit? Python<pre><code>def roll_with_crit():\n    roll = random.randint(1, 20)\n    if roll &lt; crit_threshold:\n        return 2 * random.randint(1, 6)\n    return roll\n</code></pre> Arbitrary distribution: a distribution that is not uniform, normal, or asymmetric use die-size to control the scale</p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/","title":"Index","text":"<p>Note</p> <p>CA is a course following computer organization design, aiming at quantitatively evaluating the performance of computer systems and designing more complex CPUs on FPGA. Despite being an hardware course, understanding the basic principles of computer architecture is essential for software engineers, especially for us interested in AI for ultization of computer hardware to exploit performance, which DeepSeek has been doing. </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/","title":"ILP","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#review-of-pipeline-hazards","title":"Review of Pipeline Hazards","text":"<ul> <li>Structural Hazards</li> <li>Occur when two or more instructions require the same hardware resource at the same time.</li> <li> <p>Example: Two instructions trying to access the same memory location simultaneously.</p> </li> <li> <p>Data Hazards</p> <ul> <li>Occur when an instruction depends on the result of a previous instruction that has not yet completed.</li> <li>Types:<ul> <li>Read After Write (RAW): An instruction reads a value before it is written by a previous instruction.</li> <li>Write After Read (WAR): An instruction writes a value before it is read by a previous instruction.</li> <li>Write After Write (WAW): Two instructions write to the same location, and the order of writes matters.</li> </ul> </li> </ul> </li> <li> <p>Control Hazards</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#pipelining-some-of-the-fp-units","title":"Pipelining some of the FP units","text":"<p>Terminology</p> <p></p> <ul> <li> <p>unpipelined structure, structural hazard may occur</p> </li> <li> <p>use delay counting while implemented on verilog in labs</p> </li> <li> <p>data hazards and exceptions</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#stalls-arising-from-raw-hazards","title":"Stalls arising from RAW hazards","text":"<ul> <li>load stall</li> <li>stall because of previous stalls(sequential issue)</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#solving-waw-hazards","title":"Solving WAW hazards","text":"<ul> <li>stall until the previous instruction has written its result(WB)</li> <li>do not WB the previous instruction</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#check-for-waw-hazards","title":"Check for WAW hazards","text":"<p>Check for Hazards</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#the-mips-r4000-pipeline","title":"The MIPS R4000 Pipeline","text":"<ul> <li>use instruction manipulation</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#what-is-ilp","title":"What is ILP?","text":"<ul> <li> <p>Basic Block is quite small</p> </li> <li> <p>reduce CPI</p> </li> <li> <p>Hardware-based dynamic approaches</p> </li> <li> <p>compiler based</p> </li> <li> <p>loop-level parallelism</p> </li> </ul> <p>vector based instructions(GPU is the way)</p> <p>dynamic branch</p> <ul> <li>name dependence</li> </ul> <p>renaming</p> <ul> <li>true dependency</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#lecture-for-ilp-software-approaches","title":"Lecture for ILP: Software approaches","text":"<p>Content</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#dynamic-scheduling","title":"Dynamic Scheduling","text":"<ul> <li>issue and read operand: should be separated</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#scoreboarding","title":"Scoreboarding","text":"<ul> <li>in-order issue</li> <li> <p>out-of-order completion</p> </li> <li> <p>Pipeline stages with scoreboard:</p> </li> </ul> <p>IF, IS, RO, EX, WB</p> ConceptMore specific <p>Scoreboard Basic Concept</p> <p></p> <p>More Specific</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#limitations-of-scoreboard","title":"Limitations of Scoreboard","text":"<ul> <li> <p>size of issue queue</p> </li> <li> <p>WAR and WAW</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#tomasulos-algorithm","title":"Tomasulo's Algorithm","text":"<ul> <li> <p>Common Data Pass:</p> </li> <li> <p>Op, Vj(Value of Operands), Vk, Qj(reservation station code), Qk, A, Busy</p> </li> </ul> <p>Basic Operation</p> <p></p> <ul> <li> <p>overlap iterations of loop(when load, etc)</p> </li> <li> <p>non-precise interrupts</p> </li> </ul> <p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#what-about-precise-interrupts","title":"What about Precise Interrupts?","text":"<ul> <li>reordered buffer</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#explicit-register-renaming","title":"Explicit Register Renaming","text":"<ul> <li> <p>renaming physical registers</p> </li> <li> <p>precise interrupts: </p> </li> </ul> <p>future file: when ensured that the instruction is no interrupts thus needed writng, the written process can be done</p> <p>history file: store in the physical register, yet the previous, or old register will be preserved</p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#dynamic-hardware-prediction","title":"Dynamic Hardware Prediction","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#one-bit-branch-prediction-buffer","title":"One bit Branch-Prediction Buffer","text":"<p>take the previous \"whether jump\"</p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#two-bit-branch-prediction","title":"Two bit Branch Prediction","text":"<p>a state machine or a counter</p> <p>but 1 0 1 0 1 0 is not as efficient as one-bit buffer</p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#generalize-the-2-bit-predictor-to-the-n-bit-predictor","title":"Generalize the 2-bit predictor to the n-bit predictor","text":"<p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#correlating-branch-predictionmn","title":"Correlating Branch Prediction(m,n)","text":"<ul> <li> <p>m-bit history register(\\(2^m\\) situations)</p> </li> <li> <p>n-bit saturating counter</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#tournament-predictors","title":"Tournament Predictors","text":"<ul> <li>global and local predictors work together</li> </ul> <p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#gshare","title":"Gshare","text":"<p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#branch-target-buffer","title":"Branch Target Buffer","text":"<ul> <li>store whether jump and the address</li> </ul> <p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#integrated-instruction-fetch","title":"Integrated Instruction Fetch","text":"<ul> <li>fetch and branch-predict</li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ARCHITECTURE/Chapter_Three_ILP/#return-address-predictor","title":"Return Address Predictor","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/","title":"Index","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/#computer-graphics","title":"Computer Graphics","text":"<p>Note</p> <p> Fundimental course of computer graphics.  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/","title":"OpenGL","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#getting-started","title":"Getting Started","text":"<ul> <li> <p>OpenGL is a large state machine, a collection of variables that define how OpenGL should currently operate.     </p> </li> <li> <p>Object: An object in OpenGL is a collection of options that represents a subset of OpenGL's state. For example, we could have an object that represents the settings of the drawing window; we could then set its size, how many colors it supports and so on.   </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#create-a-window","title":"Create a Window","text":"<ul> <li>Configure the window C++<pre><code>int main()  \n{\n    glfwInit();  \n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);  \n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);  \n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);  \n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);//on mac    \n    return 0;\n}  \n</code></pre></li> <li>Create the window C++<pre><code>GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL);  \nif (window == NULL)  \n{  \n    std::cout &lt;&lt; \"Failed to create GLFW window\" &lt;&lt; std::endl;  \n    glfwTerminate();  \n    return -1;  \n}\nglfwMakeContextCurrent(window);  \n</code></pre></li> <li>Load GLAD C++<pre><code>if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))  \n{  \n    std::cout &lt;&lt; \"Failed to initialize GLAD\" &lt;&lt; std::endl;  \n    return -1;  \n}  \n</code></pre></li> <li> <p>Set the viewport C++<pre><code>glViewport(0, 0, 800, 600);  \n</code></pre></p> <p>The first two parameters of glViewport set the location of the lower left corner of the window. The third and fourth parameter set the width and height of the rendering window in pixels, which we set to 800 and 600, respectively.  </p> </li> <li> <p>Resize the window C++<pre><code>void framebuffer_size_callback(GLFWwindow* window, int width, int height)  \n{  \n    glViewport(0, 0, width, height);  \n}\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);  \n</code></pre></p> </li> <li> <p>Render loop C++<pre><code>while(!glfwWindowShouldClose(window))  \n{  \n    processInput(window);  \n    glfwSwapBuffers(window);  \n    glfwPollEvents();  \n}  \n</code></pre></p> <p>The glfwWindowShouldClose function checks at the start of each loop iteration if GLFW has been instructed to close. If so, the function returns true and the render loop stops running, after which we can close the application. The glfwPollEvents function checks if any events are triggered (like keyboard input or mouse movement events), updates the window state, and calls the corresponding functions (which we can register via callback methods). The glfwSwapBuffers will swap the color buffer (a large 2D buffer that contains color values for each pixel in GLFW's window) that is used to render to during this render iteration and show it as output to the screen.  </p> </li> <li> <p>Double Buffer  </p> <p>When an application draws in a single buffer the resulting image may display flickering issues. This is because the resulting output image is not drawn in an instant, but drawn pixel by pixel and usually from left to right and top to bottom. Because this image is not displayed at an instant to the user while still being rendered to, the result may contain artifacts. To circumvent these issues, windowing applications apply a double buffer for rendering. The front buffer contains the final output image that is shown at the screen, while all the rendering commands draw to the back buffer. As soon as all the rendering commands are finished we swap the back buffer to the front buffer so the image can be displayed without still being rendered to, removing all the aforementioned artifacts.  </p> </li> <li> <p>Termination C++<pre><code>glfwTerminate();  \nreturn 0;  \n</code></pre></p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#input","title":"Input","text":"C++<pre><code>void processInput(GLFWwindow *window)  \n{  \n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)  \n        glfwSetWindowShouldClose(window, true);  \n}  \n</code></pre> <p>The glfwGetKey function takes the window as input together with a key. It returns whether this key is currently being pressed. If it is being pressed, the function returns GLFW_PRESS, if it is not being pressed, it returns GLFW_RELEASE.  </p> C++<pre><code>while (!glfwWindowShouldClose(window))  \n{  \n    processInput(window);  \n    glfwSwapBuffers(window);  // rendering commands here  \n    glfwPollEvents();\n\n}  \n</code></pre> <p>This gives an easy way to check for specific key presses and react accordingly every frame.  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#rendering","title":"Rendering","text":"<ul> <li>We want to place all the rendering commands within the render loop. C++<pre><code>while (!glfwWindowShouldClose(window))  \n{  \n    processInput(window);  \n    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);  \n    glClear(GL_COLOR_BUFFER_BIT);  \n    glfwSwapBuffers(window);  \n    glfwPollEvents();  \n}  \n</code></pre> <p>Just to test if things actually work we want to clear the screen with a color of our choice. At the start of frame we want to clear the screen. Otherwise we would still see the results from the previous frame (this could be the effect you're looking for, but usually you don't). We can clear the screen's color buffer using glClear where we pass in buffer bits to specify which buffer we would like to clear. The possible bits we can set are GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT. Right now we only care about the color values so we only clear the color buffer.  </p> </li> </ul> C++<pre><code>glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    \nglClear(GL_COLOR_BUFFER_BIT);  \n</code></pre> <p>The glClearColor function is a state-setting function and glClear is a state-using function. The glClearColor function sets the color that is used when calling the glClear function. The glClear function is used to clear the color buffer.  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#hello-triangle","title":"Hello Triangle","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#graphics-pipeline","title":"Graphics Pipeline","text":"<ul> <li>shaders   <p>written in OpenGL Shading Language (GLSL)    </p> </li> </ul> <p>Graphics Pipeline brief illustration</p> <p> </p> <p>In order for OpenGL to know what to make of your collection of coordinates and color values OpenGL requires you to hint what kind of render types you want to form with the data. Do we want the data rendered as a collection of points, a collection of triangles or perhaps just one long line? Those hints are called primitives and are given to OpenGL while calling any of the drawing commands. Some of these hints are GL_POINTS, GL_TRIANGLES and GL_LINE_STRIP where the latter hints OpenGL to render the data as a collection of points, triangles or a strip of lines respectively.  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#vertex-input","title":"Vertex Input","text":"<ul> <li> <p>To start drawing something we have to first give OpenGL some input vertex data. OpenGL is a 3D graphics library so all coordinates that we specify in OpenGL are in 3D (x, y and z coordinate). OpenGL doesn't simply transform all your 3D coordinates to 2D pixels on your screen; OpenGL only processes 3D coordinates when they're in a specific range between -1.0 and 1.0 on all 3 axes (x, y and z). All coordinates within this so called normalized device coordinates range will end up visible on your screen (and all coordinates outside this region won't).   </p> </li> <li> <p>Vertex Buffer  </p> <p>With the vertex data defined we'd like to send it as input to the first process of the graphics pipeline: the vertex shader. This is done by creating memory on the GPU where we store the vertex data, configure how OpenGL should interpret the memory and specify how to send the data to the graphics card. The vertex shader then processes as much vertices as we tell it to from its memory.</p> </li> </ul> <p>We manage this memory via so called vertex buffer objects (VBO) that can store a large number of vertices in the GPU's memory. The advantage of using those buffer objects is that we can send large batches of data all at once to the graphics card, and keep it there if there's enough memory left, without having to send data one vertex at a time. Sending data to the graphics card from the CPU is relatively slow, so wherever we can we try to send as much data as possible at once. Once the data is in the graphics card's memory the vertex shader has almost instant access to the vertices making it extremely fast  </p> <ul> <li> <p>A vertex buffer object is our first occurrence of an OpenGL object as we've discussed in the OpenGL chapter. Just like any object in OpenGL, this buffer has a unique ID corresponding to that buffer, so we can generate one with a buffer ID using the glGenBuffers function: C++<pre><code>unsigned int VBO;    \nglGenBuffers(1, &amp;VBO);  \n</code></pre></p> </li> <li> <p>bind buffer  </p> <p>After generating the buffer object we want to bind it so any subsequent buffer manipulation calls will affect this buffer. We can bind the buffer using the GL_ARRAY_BUFFER target, a type which can only signed to a particular buffer: C++<pre><code>glBindBuffer(GL_ARRAY_BUFFER, VBO);  \n</code></pre></p> </li> <li> <p>Then we can make a call to the glBufferData function that copies the previously defined vertex data into the buffer's memory: C++<pre><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);  \n</code></pre></p> </li> <li> <p>The fourth parameter has three types </p> <ul> <li>GL_STATIC_DRAW: the data will most likely not change at all or very rarely, yet used many times.  </li> <li>GL_DYNAMIC_DRAW: the data is likely to change a lot and used many times.  </li> <li>GL_STREAM_DRAW: the data is set only once and used by the GPU at most a few times. </li> </ul> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#vertex-shader","title":"Vertex Shader","text":"<p>C++<pre><code>#version 330 core  \nlayout (location = 0) in vec3 aPos;  \nvoid main()  \n{  \n    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);  \n}  \n</code></pre> * The first line specifies the version of GLSL we're using (in this case, version 3.3). * The second line specifies the input of the vertex shader. The vertex shader receives its input straight from the vertex data so we have to specify what kind of input we're feeding it. We do this by declaring the input variables with the in keyword. The location specifier is an input layout qualifier that specifies at what location the input variable is in the vertex data. * The main function is the entry point of the shader that gets called for each vertex we specify. The vertex shader should set gl_Position to a vec4 that specifies the position of the vertex.  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#compile-a-shader","title":"Compile a shader","text":"<p>C++<pre><code>const char *vertexShaderSource = \"#version 330 core\\n\"  \n    \"layout (location = 0) in vec3 aPos;\\n\"  \n    \"void main()\\n\"  \n    \"{\\n\"  \n    \"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\"  \n    \"}\\0\";  \n</code></pre> * we store the vertex shader source code in a C string. * In order for OpenGL to use the shader it has to dynamically compile it at run-time from its source code. The first thing we need to do is create a shader object, again referenced by an ID. So we store the vertex shader as an unsigned int and create the shader with glCreateShader: C++<pre><code>unsigned int vertexShader;  \nvertexShader = glCreateShader(GL_VERTEX_SHADER);  \n</code></pre></p> <p>We provide the type of shader we want to create as an argument to glCreateShader. Since we're creating a vertex shader we pass in GL_VERTEX_SHADER. C++<pre><code>glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);  \nglCompileShader(vertexShader);  \n</code></pre> The glShaderSource function takes the shader object to compile to as its first argument. The second argument specifies how many strings we're passing as source code, which is only one. The third parameter is the actual source code of the vertex shader and we can leave the 4<sup>th</sup> parameter to NULL.      </p> <ul> <li>Check if the shader compiled successfully C++<pre><code>int success;  \nchar infoLog[512];  \nglGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);  \nif(!success)  \n{  \n    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);  \n    std::cout &lt;&lt; \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl;  \n}  \n</code></pre> <p>We can retrieve the compile errors with the glGetShaderiv function that retrieves the compile status of the shader. We pass in the shader object and the status type we want to retrieve. If the compilation failed we can retrieve the error message with the glGetShaderInfoLog function. We pass in the shader object, the size of the buffer the error message should be stored in, a pointer to a variable that will store the length of the error message and a buffer that will store the error message.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#fragment-shader","title":"Fragment shader","text":"<ul> <li>Colors in computer graphics are represented as an array of 4 values: the red, green, blue and alpha (opacity) component, commonly abbreviated to RGBA. When defining a color in OpenGL or GLSL we set the strength of each component to a value between 0.0 and 1.0. If, for example, we would set red to 1.0 and green to 1.0 we would get a mixture of both colors and get the color yellow. Given those 3 color components we can generate over 16 million different colors! C++<pre><code>const char *fragmentShaderSource = \"#version 330 core\\n\"  \n    \"out vec4 FragColor;\\n\"  \n    \"void main()\\n\"  \n    \"{\\n\"  \n    \"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\"  \n    \"}\\n\\0\";  \n</code></pre></li> <li>The out keyword is used for defining output variables.  </li> <li>The vec4 type is a 4-component vector that we use to represent the color.  </li> <li>The main function of the fragment shader is quite simple: it sets the output color to orange with full opacity. C++<pre><code>unsigned int fragmentShader;  \nfragmentShader = glCreateShader(GL_FRAGMENT_SHADER);  \nglShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);  \nglCompileShader(fragmentShader);  \n</code></pre></li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#shader-program","title":"Shader Program","text":"<p>C++<pre><code>unsigned int shaderProgram;  \nshaderProgram = glCreateProgram();  \nglAttachShader(shaderProgram, vertexShader);  \nglAttachShader(shaderProgram, fragmentShader);  \nglLinkProgram(shaderProgram);  \n</code></pre> * to check if the linking was successful C++<pre><code>int success;\nchar infoLog[512];\nglGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);\nif(!success)\n{\n    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);\n    std::cout &lt;&lt; \"ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\" &lt;&lt; infoLog &lt;&lt; std::endl;\n}\n</code></pre> * activate the shader program C++<pre><code>glUseProgram(shaderProgram);\n</code></pre> * delete the shader objects once we've linked them into a program; we no longer need them. C++<pre><code>glDeleteShader(vertexShader);\nglDeleteShader(fragmentShader);\n</code></pre></p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#linking-vertex-attributes","title":"Linking Vertex Attributes","text":"<ul> <li>The vertex shader allows us to specify any input we want in the form of vertex attributes and while this allows for great flexibility, it does mean we have to manually specify what part of our input data goes to which vertex attribute in the vertex shader. This means we have to specify how OpenGL should interpret the vertex data before rendering.  </li> </ul> <p>C++<pre><code>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n</code></pre> * Each vertex attribute takes its data from memory managed by a VBO and which VBO it takes its data from (you can have multiple VBOs) is determined by the VBO currently bound to GL_ARRAY_BUFFER when calling glVertexAttribPointer. Since the previously defined VBO is still bound before calling glVertexAttribPointer vertex attribute 0 is now associated with its vertex data!  </p> <ul> <li>drawing an object is something like this C++<pre><code>// 0. copy our vertices array in a buffer for OpenGL to use\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n// 1. then set the vertex attributes pointers\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);  \n// 2. use our shader program when we want to render an object\nglUseProgram(shaderProgram);\n// 3. now draw the object \nsomeOpenGLFunctionThatDrawsOurTriangle();  \n</code></pre></li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#vertex-array-object","title":"Vertex Array Object","text":"create a VAO object C++<pre><code>unsigned int VAO;  \nglGenVertexArrays(1, &amp;VAO);   \n</code></pre> bind the VAO C++<pre><code>glBindVertexArray(VAO);  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#draw-triangle","title":"Draw triangle","text":"C++<pre><code>glUseProgram(shaderProgram);\nglBindVertexArray(VAO);  \nglDrawArrays(GL_TRIANGLES, 0, 3);  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#element-buffer-objects","title":"Element Buffer Objects","text":"<p>C++<pre><code>float vertices[] = {  \n    0.5f,  0.5f, 0.0f,  // top right  \n    0.5f, -0.5f, 0.0f,  // bottom right  \n    -0.5f, -0.5f, 0.0f,  // bottom left  \n    -0.5f,  0.5f, 0.0f   // top left  \n};  \nunsigned int indices[] = {  \n    0, 1, 3,  // first triangle  \n    1, 2, 3   // second triangle  \n};  \n</code></pre> * create a new buffer object for the indices C++<pre><code>unsigned int EBO;  \nglGenBuffers(1, &amp;EBO);  \n</code></pre></p> <ul> <li> <p>bind the EBO C++<pre><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);  \nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);  \n</code></pre></p> </li> <li> <p>draw the object C++<pre><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);  \n</code></pre></p> </li> <li> <p>The last parameter of glDrawElements is of type void* and thus requires a cast. This parameter is called the offset of the EBO and is currently set to 0.</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#draw-a-rectangle","title":"Draw a rectangle","text":"C++<pre><code>// ..:: Initialization code :: ..\n// 1. bind Vertex Array Object\nglBindVertexArray(VAO);\n// 2. copy our vertices array in a vertex buffer for OpenGL to use\nglBindBuffer(GL_ARRAY_BUFFER, VBO);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n// 3. copy our index array in a element buffer for OpenGL to use\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n// 4. then set the vertex attributes pointers\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);  \n\n[...]\n\n// ..:: Drawing code (in render loop) :: ..\nglUseProgram(shaderProgram);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\nglBindVertexArray(0);  \n</code></pre> <ul> <li>wireframe mode C++<pre><code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);  \n</code></pre> C++<pre><code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);  \n</code></pre></li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#shaders","title":"Shaders","text":"<ul> <li>Shaders always begin with a version declaration, followed by a list of input and output variables, uniforms and its main function. Each shader's entry point is at its main function where we process any input variables and output the results in its output variables.   </li> </ul> C++<pre><code>#version version_number\nin type in_variable_name;\nin type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nvoid main()\n{\n  // process input(s) and do some weird graphics stuff\n  ...\n  // output processed stuff to output variable\n  out_variable_name = weird_stuff_we_processed;\n}  \n</code></pre> <ul> <li> <p>vertex attributes:  </p> </li> <li> <p>When we're talking specifically about the vertex shader each input variable is also known as a vertex attribute. There is a maximum number of vertex attributes we're allowed to declare limited by the hardware. OpenGL guarantees there are always at least 16 4-component vertex attributes available, but some hardware may allow for more which you can retrieve by querying GL_MAX_VERTEX_ATTRIBS  </p> </li> </ul> C++<pre><code>int nrAttributes;\nglGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);\nstd::cout &lt;&lt; \"Maximum nr of vertex attributes supported: \" &lt;&lt; nrAttributes &lt;&lt; std::endl;  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#types","title":"Types","text":"<ul> <li>GLSL has most of the default basic types we know from languages like C: int, float, double, uint and bool.  </li> <li>vectors and matrices  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#vectors","title":"Vectors","text":"<ul> <li>A vector in GLSL is a 2,3 or 4 component container for any of the basic types just mentioned.    </li> </ul> <ul> <li>vecn: the default vector of n floats.</li> <li>bvecn: a vector of n booleans.</li> <li>ivecn: a vector of n integers.</li> <li>uvecn: a vector of n unsigned integers.</li> <li>dvecn: a vector of n double components.  </li> </ul> <ul> <li> <p>Components of a vector can be accessed via vec.x where x is the first component of the vector. You can use .x, .y, .z and .w to access their first, second, third and fourth component respectively. GLSL also allows you to use rgba for colors or stpq for texture coordinates, accessing the same components.   </p> </li> <li> <p>swizzling </p> </li> </ul> C++<pre><code>vec2 someVec;  \nvec4 differentVec = someVec.xyxx;  \nvec3 anotherVec = differentVec.zyw;    \nvec4 otherVec = someVec.xxxx + anotherVec.yxzy;    \n</code></pre> C++<pre><code>vec2 vect = vec2(0.5, 0.7);\nvec4 result = vec4(vect, 0.0, 0.0);\nvec4 otherResult = vec4(result.xyz, 1.0);  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20GRAPHICS/OpenGL/#ins-and-outs","title":"Ins and Outs","text":"<ul> <li> <p>Shaders are nice little programs on their own, but they are part of a whole and for that reason we want to have inputs and outputs on the individual shaders so that we can move stuff around. GLSL defined the in and out keywords specifically for that purpose. Each shader can specify inputs and outputs using those keywords and wherever an output variable matches with an input variable of the next shader stage they're passed along.  </p> </li> <li> <p>Uniform:</p> </li> </ul> <p>A uniform is a global variable that is declared with the uniform keyword. Uniforms are used to pass data from the CPU to the GPU and are read-only in the shader. They are set once per draw call and can be used to pass data such as transformation matrices, colors, or any other data that needs to be consistent across all vertices or fragments.  </p> C++<pre><code>float timeValue = glfwGetTime();\nfloat greenValue = (sin(timeValue) / 2.0f) + 0.5f;\nint vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");\nglUseProgram(shaderProgram);\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n</code></pre> <p>Note that finding the uniform location does not require you to use the shader program first, but updating a uniform does require you to first use the program (by calling glUseProgram), because it sets the uniform on the currently active shader program.</p> C++<pre><code>while(!glfwWindowShouldClose(window))\n{\n    // input\n    processInput(window);\n\n    // render\n    // clear the colorbuffer\n    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // be sure to activate the shader\n    glUseProgram(shaderProgram);\n\n    // update the uniform color\n    float timeValue = glfwGetTime();\n    float greenValue = sin(timeValue) / 2.0f + 0.5f;\n    int vertexColorLocation = glGetUniformLocation(shaderProgram, \"ourColor\");\n    glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n\n    // now render the triangle\n    glBindVertexArray(VAO);\n    glDrawArrays(GL_TRIANGLES, 0, 3);\n\n    // swap buffers and poll IO events\n    glfwSwapBuffers(window);\n    glfwPollEvents();\n}\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/","title":"COD","text":"<p>Note</p> <p>The fundamental course of computer hardware</p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Four/","title":"The Processor","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Four/#41-introduction","title":"4.1 Introduction","text":"<ul> <li>Chapter One:   <p>Explain that the performance of a computer is determined by three key factors: instruction count, clock cycle time, and clock cycles per instruction (CPI).  </p> </li> <li>Chapter Two:   <p>Explain that the compiler and the instruction set architecture determine the instruction count required for a given program. However, the implementation of the processor determines both the clock cycle time and the number of clock cycles per instruction. In this chapter, we construct the datapath and control unit for two different implementations of the RISC-V instruction set.  </p> </li> <li>This Chapter:   <p>This chapter contains an explanation of the principles and techniques used in implementing a processor, starting with a highly abstract and simplified overview in this section. It is followed by a section that builds up a datapath and constructs a simple version of a processor sufficient to implement an instruction set like RISC-V. The bulk of the chapter covers a more realistic pipelined RISC-V implementation, followed by a section that develops the concepts necessary to implement more complex instruction sets, like the x86.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Four/#an-overview","title":"An overview","text":"Major FunctionMajor Function With Control <p>Note</p> <p> </p> <p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Four/#42-logic-design-convention","title":"4.2 Logic Design Convention","text":"<ul> <li>Information are encoded in binary to make the information conveyed less sensitive, hence more resilient to noise   <p>One wire per bit, multi-bit encoded on multi-wire buses combinational curcuits perform data processing sequential circuits store state Sequential Elements </p> </li> <li>register: stores data in circuit   <p>when clk changes from 0 to one, update with delay a write control shall be implemented in regs-&gt;Update only when write control is <code>1</code> Clocking Methodology </p> </li> <li>Combinational logic transforms data during clock cycles   <p>its longest delay determines the clock period   </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Four/#43-building-a-datapath","title":"4.3 Building a Datapath","text":"<ul> <li>Datapath:   <p>elements that process data and addresses in the CPU basic procedure </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Four/#45-an-overview-of-pipeling","title":"4.5 An Overview of Pipeling","text":"<ul> <li>Pipelining:   <p>An implementation technique in which multiple instructions are overlapped in execution, much like an assembly line.  </p> </li> </ul> <p>Intro</p> <p> The same principle can be applied to instruction execution </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/","title":"Arithmetic","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#31-intro","title":"3.1 Intro","text":"<p>Question</p> <p>Fractions, real numbers, overflow, and how hardware do multiplication and division. </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#32-addition-and-subtraction","title":"3.2 Addition and Subtraction","text":"<ul> <li>Addition: add from right to left, carry bit  </li> <li>Subtraction: directly or via 2's complement  </li> <li>Overflow: differnet signs: cannot occur  overflow occurs when adding two positive numbers and the sum is negative, or vice versa. This spurious sum means a carry out occurred into the sign bit. unsigned overflow: used in memory addresses, where overflow is usually ignored. It is easy to detect, for the result smaller than any addends while adding , or the difference bigger than the minuend while subtracting.   </li> </ul> <p>Warning</p> <p>RISC-V does not have arithmetic operations on byte or halfwords, yet it can still load and store them. </p> <p>Saturation: when a calculation overflows, the result is set to the largest positive number or the most negative number, rather than a modulo calculation as in two\u2019s complement arithmetic. (media operations, volumn knob)  </p> <p>Acceleration</p> <p>implementing anticipation of carries accelerate the adding process, add reduce the time complexity to \\(O(\\log n)\\) </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#impelmentation","title":"Impelmentation","text":"<p>  a basic implementation of a 64-bit ALU: a ripple-carry adder  significant bit: \u6743\u91cd\uff0c\u4f4d\u6b21   To make it available to calculate negative numbers, we can use 2's complement, and add a carry at the least significant bit.  To make the ALU more suitable for RISC-V: we need only connect the sign bit from the adder output to the least significant bit to get set less than(no overflow)  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#33-multiplication","title":"3.3 Multiplication","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#34-division","title":"3.4 Division","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#35-floating-point","title":"3.5 Floating Point","text":"<ol> <li>float: 32-bit, 1 bit for sign, 8 bit for exponent and 23 bit for fraction </li> <li>double: 64-bit, 1 bit for sign, 11 bit for exponent and 52 bit for fraction  </li> <li>interrupt: The address of the instruction that overflowed is saved in a register, and the computer jumps to a predefined address to invoke the appropriate routine for that exception.  </li> </ol>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Three/#ieee-754-floating-point-standard","title":"IEEE 754 Floating-Point Standard","text":"<ol> <li> <p>make the leading 1 bit of normalized binary number implicit, therefore, one plus the fraction is named \\(significand\\) </p> <ul> <li>Since 0 has no leading 1, it is given the reserved exponent value 0 so that the hardware won\u2019t attach a leading 1 to it  </li> </ul> </li> <li> <p>NaN: Not a Number, used to represent the result of an invalid operation, such as 0/0 or \\(\\infty/\\infty\\) </p> </li> <li>IEEE 754 always keeps two extra bits on the right during intervening additions, called guard and round, 0 to 49 to round down and 51 to 99 to round up   </li> <li>units in the last place:  (ulp) The number of bits in error in the least significant bits of the significand between the actual number and the number that can be represented.  </li> <li>three extra digits are kept in the significand to prevent rounding errors from accumulating.\uff08guard, round, and sticky bits\uff0c used in rounding to the nearest even\uff09  Assembly \\(-&gt;\\) Machine Code operands </li> </ol> <p> </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/","title":"Instructions","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#memory-layout","title":"Memory Layout","text":"<p> The reason for using iteration to replace recursion: - The size of the stack is limited - The computer is vulnerable - Registers and addresses are stored and protected in the stack - Too much recursion leads to stack overflow</p> <p>Frame Pointer: Located at the bottom of the stack, for faster addressing</p> <p>Tip</p> <p>Use the \"nickname\" </p> <p></p> <p>W type operator: * Single word  </p> <p> </p> <p>Tip</p> <p>For all the jumping operations, <code>beq</code> and <code>bne</code> are enough </p> <p><code>jal</code>, <code>jalr</code></p> <p>Warning</p> <p>The MIPS instruction set is different from RISC-V, don't mix the two. </p> <p> </p> <p>ASCII: Abundant at first (English, Latin) Unicode: 32-bit character set (standard) * Widely used in programming languages   </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#bytehalfwordword-operations","title":"Byte/Halfword/Word Operations","text":"<p>Warning</p> <p>All the operations are presented in 32-bit in the experiment section. </p> <p> Reduce the usage of saved registers * In embedded development, every bit of memory matters * Although embedded development is difficult, it is the trend. Some students will be forced by life... (Quoted from Prof. Ma De)  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#immediate-number-and-address","title":"Immediate number and address","text":"<p>If the number is too large, larger than 12-bit <code>lui</code>:   contains storage of 20-bit  </p> Why 20-bit? <p>when you want to add <code>addi</code> </p> <p> </p> <ul> <li>SB-type *Not suitable for Chinese students :  \u6307\u4ee4\u5730\u5740\u4e00\u5b9a\u8981\u5bf9\u9f50(half-word alignment: preparation for ARM ISA)  \u56e0\u6b64\u6ca1\u6709\u7b2c\u4e00\u4f4d  </li> <li>UJ FORMAT *:    When the address is too big, use <code>lui</code> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#collection-of-instructions","title":"Collection of Instructions","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#synchronization-in-risc-v","title":"Synchronization in RISC-V","text":"<ul> <li>nobody can interrupt the atomic operation  <code>lr.d</code> and <code>sc.d</code> </li> <li><code>lr.d</code> is used to load the value of the address into the register, thus the CPU remembers the operation lr.d   </li> <li><code>sc.d</code> is used to store the value of the register into the address, lr.d and sr.d are a pair of operations, and the CPU will check if the value of the address has been changed during the operation. If it has not been changed, the operation is successful. Ohterwise its not.  </li> </ul> <p>Example</p> <p>r20-&gt;7 then lr.d s2 (r20) s2=7 CPU remebers the procedure  sc.d rd (r20) s2 the value on the (r20) address might be changed because of multi-core structure, when encountered this situation, 1 will be stored in rd(unsuccessful, the value of s2 cannot be stored in that memory).  </p> <p> No interruption is allowed in cpu, one paticular address need to be locked, so that no other cpu can access it. </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#translating-and-staring-a-program","title":"Translating and staring a program","text":"<p>  when learning compiling     .dll is a dynamic link library, which is a collection of small programs, any of which can be called when needed by a larger program that is running in the computer. The small program that lets the larger program communicate with a specific device such as a printer or scanner is often packaged as a DLL program (usually referred to as a DLL file). Starting Java Applications the virtual machine of Java allows Java to be run on any platform. </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#a-c-sort-example-to-pull-it-all-together","title":"A C Sort Example To Pull It All Together","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#arrays-versus-pointers","title":"Arrays Versus Pointers","text":"<p>(comilers are smart enough to optimize the code, to change the array to pointer and vice versa) </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#real-stuff-mips-instrcuctions","title":"Real Stuff: MIPS Instrcuctions","text":"<p>all 32-bit instructions  the difference:  reverse version of RISC-V the store instruction is the same as the load instruction not successful in the market </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#real-stuff-the-intel-x86-isa","title":"Real Stuff: The Intel x86 ISA","text":"<p>8080: 8-bit 8086: 16-bit Further evolution: * AMD64(64) regs have 32bits and 64bits Too complex!!! Mac: ARM, \u5916\u661f\u79d1\u6280\uff01\uff01\uff01  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#implementing-ia-32","title":"Implementing IA-32","text":"<ul> <li>All things taught in this course is RV64I There is extentions: M,A,F,D,C    </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Chapter_Two/#fallacies","title":"Fallacies","text":"<ul> <li>Poerful instruction -&gt; higher performance No!!!  </li> <li>Backward compatibility -&gt; ISA doesn't change No!!!  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Exception/","title":"Supplement for Exception","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Exception/#cpu-within-exception","title":"CPU within Exception","text":"<ul> <li>execute a new function when an exception occurs  </li> <li>CPU don't need to save time for unexpected events  </li> <li><code>bne</code>, <code>beq</code> will cause a diffferent operation in PC  </li> <li>but sometimes the hardware will urge the CPU to do something unexpected  </li> <li>within the processor: Expection  </li> <li>from outside the processor: Interrupt  </li> <li>What must the processor do:  <p>A predefined process routine  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Exception/#risc-v-privileged","title":"RISC-V Privileged","text":"<ul> <li>CPU: user operation, many regs cannot be accessed, only access to ports provided by operating system  </li> <li>Monitoring: Operating System (S) </li> <li>Machine Mode: highest privilege, having access to everything  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Exception/#control-and-status-registers","title":"Control and Status Registers","text":"<ul> <li>Environment call(ecall) MEPC-&gt;&amp;ecall(exception, interrupt is PC+4)</li> <li>Breakpoint (ebreak)  MEPC-&gt;&amp;ebreak  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Memory_Elements/","title":"Memory Elements","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Memory_Elements/#flip-flops-and-latches","title":"Flip-Flops and Latches","text":"<ul> <li>Latch: A memory element in which the output is equal to the value of the stored state inside the element and the state is changed whenever the appropriate inputs change and the clock is asserted.  </li> <li>Flip-Flop: A memory element for which the output is equal to the value of the stored state inside the element and for which the internal state is changed only on a clock edge.</li> </ul> D latchOperation of D latchD flip-flop with a falling edge triggerOperation of D flip-flopImplementation of D flip-flop with rising edge <p>D latch</p> <p> </p> <p>Note</p> <p></p> <p>Note</p> <p> </p> <p>Note</p> <p> </p> Verilog<pre><code>   module DFF(clock,D,Q,Qbar);\n       input clock, D;\n       output reg Q;\n       output Qbar;\n       assign Qbar = ~Q;  \n       always @(posedge clock)\n           Q = D;\n    endmodule\n</code></pre> <ul> <li>Setup Time:   <p>Because the D input is sampled on the clock edge, it must be valid for a period of time immediately before and immediately after the clock edge. The minimum time that the input must be valid before the clock edge is called the setup time.  </p> </li> </ul> <p>Setup Time</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Memory_Elements/#register-files","title":"Register Files","text":"<ul> <li>Register File: A register file consists of a set of registers that can be read and written by supplying a register number to be accessed. A register file can be implemented with a decoder for each read or write port and an array of registers built from D flip-flops.    </li> </ul> Register FileRegister File with Read PortsRegister File with Write PortsQuestion <p>Register File</p> <p> </p> <p>Register File with Read Ports</p> <p> </p> <p>Register File with Write Ports</p> <p> </p> <p>What happens if the same register is read and written in the same cycle?</p> <p>Because the write of the register file occurs on the clock edge, the register will be valid during the time it is read. The value returned will be the value written in an earlier clock cycle.  </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Memory_Elements/#specifying-sequential-logic-in-verilog","title":"Specifying Sequential Logic in Verilog","text":"<ul> <li>Specifying a clock:   <p>A clock is not a predefined object in Verilog; instead, we generate a clock by using the Verilog notation #n before a statement; this causes a delay of n simulation time steps before the execution of the statement. In most Verilog simulators, it is also possible to generate a clock as an external input, allowing the user to specify at simulation time the number of clock cycles during which to run a simulation. Verilog<pre><code>   reg clock;\n   always #1 clock=~clock;  \n</code></pre></p> </li> <li>Specify the operation of an edge-triggered register:   <p>In Verilog, this is done by using the sensitivity list on an always block and specifying as a trigger either the positive or negative edge of a binary variable with the notation posedge or negedge, respectively  </p> </li> </ul> registerregister file Verilog<pre><code>   reg [63:0] A;\n   wire [63:0] B;\n   always @(posedge clock)\n       A &lt;= B;\n</code></pre> Verilog<pre><code>   module registerfile(Read1,Read2,WriteReg,WriteData,RegWrite,Data1,Data2,clock);  \n          input [5:0] Read1,Read2,WriteReg;  \n          input [63:0] WriteData;  \n          input RegWrite, clock;  \n          output [63:0] Data1,Data2;  \n          reg [63:0] RF [31:0];\n          assign Data1=RF[Read1];  \n          assign Data2=RF[Read2];  \n          always begin  \n          @(posedge clock) \n          if(RegWrite) RF[WriteReg]&lt;=WriteData;  \n          end  \n    endmodule;  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Verilog/","title":"Verilog","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Verilog/#structure-of-a-verilog-program","title":"Structure of a Verilog Program","text":"<ul> <li>A Verilog program is structured as a set of modules, which may represent anything from a collection of logic gates to a complete system. Modules are similar to classes in C++, although not nearly as powerful. A module specifies its input and output ports, which describe the incoming and outgoing connections of a module. A module may also declare additional variables. The body of a module consists of:   <ul> <li><code>initial</code> constructs, which can initialize reg variables  </li> <li>Continuous assignments, which define only combinational logic  </li> <li>always constructs, which can define either sequential or combinational logic  </li> <li>Instances of other modules, which are used to implement the module being defined  </li> </ul> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Verilog/#representing-complex-combinational-logic-in-verilog","title":"Representing Complex Combinational Logic in Verilog","text":""},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Verilog/#continuous-assignments","title":"Continuous Assignments","text":"Verilog<pre><code>module half_adder(A,B,Sum,Carry);  \n    input A,B;   \n    output Sum,Carry;    \n    assign Sum = A ^ B;  \n    assign Carry = A &amp; B;  \nendmodule  \n</code></pre> <ul> <li>A continuous assignment, which is indicated with the keyword assign, acts like a combinational logic function: the output is continuously assigned the value, and a change in the input values is reflected immediately in the output value.      </li> </ul> <p>Warning</p> <p>Assign statements are one sure way to write Verilog that generates combinational logic. For more complex structures, however, assign statements may be awkward or  tedious to use. It is also possible to use the always block of a module to describe a combinational logic element, although care must be taken. Using an always block allows the inclusion of Verilog control constructs, such as if-then-else, case statements, for statements, and repeat statements, to be used. These statements are similar to those in C with small changes. </p>"},{"location":"ZJU%20CS%20COURSES/COMPUTER%20ORGANIZATION%20DESIGN/Verilog/#using-always-blocks-for-combinational-logic","title":"Using always Blocks for Combinational Logic","text":"<p>Note</p> <p>sensitivity list The list of signals that specifies when an always block should be re-evaluated. </p> Verilog<pre><code>always @(list of signals that cause reevaluation) begin\n Verilog statements including assignments and other\ncontrol statements   \nend  \n</code></pre> <ul> <li>When an always block is specifying combinational logic, the sensitivity list should include all the input signals. If there are multiple Verilog statements to  be executed in an always block, they are surrounded by the keywords begin and  end, which take the place of the { and } in C   </li> <li><code>=</code>: blocking assignment, which means that the right-hand side is evaluated and assigned to the left-hand side before the next statement is executed.  </li> <li><code>&lt;=</code>: nonblocking assignment, all right-hand sides of the assignments in an always group are evaluated and the assignments are done simultaneously  </li> </ul> Mux4to1ALU Verilog<pre><code>module mux4to1(In1,In2, In3, In4, Sel, Out);  \n    input [63:0] In1, In2, In3, In4;  \n    input [1:0] Sel;  \n    output reg [63:0] Out;  \n    always @(In1 , In2 , In3 , In4 , Sel) begin  \n        case (Sel)  \n            2'b00: Out &lt;= In1;  \n            2'b01: Out &lt;= In2;  \n            2'b10: Out &lt;= In3;  \n            2'b11: Out &lt;= In4;  \n        endcase  \n    end\nendmodule  \n</code></pre> Verilog<pre><code>module ALU(ALUctl, A,B,ALUOut, Zero);\n   input [3:0] ALUctl;  \n   input [63:0] A,B;  \n   output reg [63:0] ALUOut;  \n   output Zero;  \n   assign Zero = (ALUOut == 64'b0);  \n   always @(A,B,ALUctl) begin  \n       case (ALUctl)  \n           4'b0000: ALUOut &lt;= A + B;  \n           4'b0001: ALUOut &lt;= A - B;  \n           4'b0010: ALUOut &lt;= A &amp; B;  \n           4'b0011: ALUOut &lt;= A | B;  \n           4'b0100: ALUOut &lt;= A ^ B;  \n           4'b0101: ALUOut &lt;= ~A;  \n           4'b0110: ALUOut &lt;= ~B;  \n           4'b0111: ALUOut &lt;= A &lt;&lt; 1;  \n           4'b1000: ALUOut &lt;= A &gt;&gt; 1;  \n           4'b1001: ALUOut &lt;= A;  \n           4'b1010: ALUOut &lt;= B;  \n           4'b1011: ALUOut &lt;= 64'b0;  \n           4'b1100: ALUOut &lt;= 64'b1;  \n           4'b1101: ALUOut &lt;= 64'b0;  \n           4'b1110: ALUOut &lt;= 64'b1;  \n           4'b1111: ALUOut &lt;= 64'b0;  \n       endcase  \n   end\nendmodule  \n</code></pre> BewareTips <p>Beware</p> <p>Since only reg variables may be assigned inside always blocks, when we want to describe combinational logic using an always block, care must be taken to ensure that the reg does not synthesize into a register </p> <p>Tips</p> <ul> <li>Place all combinational logic in a continuous assignment or an always block.  </li> <li>Make sure that all the signals used as inputs appear in the sensitivity list of an always block.  </li> <li>Ensure that every path through an always block assigns a value to the exact same set of bits</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/","title":"Index","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/#database-systems","title":"Database Systems","text":"<p>Note</p> <p>The fundimental course of the database system with heavy workload on projects, especially to build a minsql from scratch</p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fifteen/","title":"Chapter Fifteen","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fifteen/#review","title":"Review","text":"<ul> <li>\u6309\u7167\u5217\u6765\u5b58\u653e\uff1a\u9002\u5408\u5206\u6790\u578b\uff08catch hit\uff0cdata compress, parallism\uff09</li> <li>query-&gt;parser and translator-&gt;relational algebra expression-&gt;optimizer\uff08statistics about data\uff09-&gt; evaluation-&gt;result</li> <li>\u8bed\u610f\u68c0\u67e5</li> <li>\u5173\u7cfb\u4ee3\u6570\u8868\u8fbe\u5f0f</li> <li>\u5229\u7528\u903b\u8f91\u8f6c\u6362\u89c4\u5219\uff1a\uff08\u5148\u7b5b\u9009\u518d join\uff09</li> <li>\u7269\u7406\u4f18\u5316\uff1a\u7528\u4ec0\u4e48\u7b97\u6cd5\u5b9e\u73b0\u4ec0\u4e48\u7b97\u5b50</li> <li>pipeline</li> <li>\u5982\u4f55\u8ba1\u7b97\u67e5\u8be2 cost\uff1a <p>[!note] </p> </li> <li>extra buffer space</li> <li>worst case estimation</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fifteen/#file-scan","title":"File Scan","text":"<ul> <li>linear search ()</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fifteen/#hash-join-algorithm","title":"Hash Join Algorithm","text":"<ol> <li> <p>Partition the relation s using hashing function h. When partitioning a relation, one block of memory is reserved as the output buffer for each partition. Partition r similarly.</p> </li> <li> <p>For each i:</p> </li> <li> <p>(A): Load si into memory and build an in-memory hash index on it using the join attribute. This hash index uses a different hash function than the earlier one h.</p> </li> <li> <p>Read the tuples in ri from the disk one by one. For each tuple tr locate each matching tuple ts in si using the in-memory hash index. Output the concatenation of their attributes.</p> </li> </ol> <p>Relation s is called the build input and r is called the probe input.</p> <ul> <li> <p>The value n and the hash function h is chosen such that each si should fit in memory.</p> </li> <li> <p>Typically n is chosen as \\(n = \\lceil \\frac{b_s}{M} \\rceil \\mul f\\) where f is a \u201cfudge factor\u201d, typically around 1.2</p> </li> <li> <p>The probe relation partitions ri need not fit in memory</p> </li> <li> <p>Recursive partitioning required if number of partitions n is greater than number of pages M of memory.</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Five/","title":"Advanced SQL","text":"<ul> <li>The SQL standard defines embeddings of SQL in a variety of programming languages such as C, Java, and Cobol.</li> <li>A language to which SQL queries are embedded is referred to as a host language, and the SQL structures permitted in the host language comprise embedded SQL.</li> <li>Main issues: exchange of parameters and results between the host language and SQL statements; sets vs. variables; get the execution status of the SQL statements; compile to host language;</li> </ul> C<pre><code>EXEC SQL update instructor set salary=salary*1.05 where salary&lt;:some_amount END_EXEC;//:some_amount is a host variable\n```c\nEXEC SQL\n   declare c cursor for     \nselect ID, name\nfrom student\nwhere tot_cred &gt; :credit_amount\nEND_EXEC\n</code></pre> <ul> <li>open: open the cursor</li> </ul> C<pre><code>EXEC SQL open c END_EXEC\n</code></pre> <ul> <li>fetch: fetch the next row from the cursor</li> </ul> C<pre><code>EXEC SQL fetch c into :student_id, :student_name END_EXEC\n</code></pre> <p>Repeated calls to fetch get successive tuples in the query result A variable called SQLSTATE in the SQL communication area (SQLCA) gets set to \u201802000\u2019 to indicate no more data is available</p> <ul> <li>close: close the cursor</li> </ul> C<pre><code>EXEC SQL close c END_EXEC\n</code></pre> <ul> <li>example:</li> </ul> C<pre><code>void getStudentInfo()\n{\n    int credit_amount;\n    char sId[16];\n    char sName[16];\n    EXEC SQL declare c cursor select id, name from student where tot_cred&gt; :credit_amount END EXEC;\n    printf(\"Please input the credit amount: \"); \n    scanf(\"%d\",&amp;credit_amount);\n    EXEC SQL open c END_EXEC;\n    while (1)\n    {\n        EXEC SQL fetch c into :sId, :sName END_EXEC;\n        if (!strcmp(SQLSTATE,\"02000\"))\n            break;\n        printf(\"%s %s\\n\",sId,sName);\n    }\n    EXEC SQL close c END_EXEC;\n}\n</code></pre> <ul> <li>updates through cursors:</li> </ul> C<pre><code>delcare c cursor for\n  select *\n  from instructor\n  where dept_name='Music'\nfor update\n</code></pre> C<pre><code>update instructor\nset salary=salary+100\nwhere current of c\n</code></pre> <ul> <li>ODBC and JDBC:</li> </ul> <p>illustration</p> <p></p> <ul> <li>Driver and DSN configuration:</li> </ul> C<pre><code>int ODBCexample()\n{\n  RETCODE error;\n  HENV    env;     /* environment */ \n  HDBC    conn;  /* database connection */ \n  SQLAllocEnv(&amp;env);\n  SQLAllocConnect(env, &amp;conn);\n  SQLConnect(conn, \u201cMike\", SQL_NTS, \"avi\", SQL_NTS, \"avipasswd\", SQL_NTS); \n  { \u2026. Do actual work , usually use a statement handle to do the querey\u2026 }\n\n  SQLDisconnect(conn); \n  SQLFreeConnect(conn); \n  SQLFreeEnv(env); \n}\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/","title":"Intermediate SQL","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#join-expressions","title":"Join Expressions","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#join-relations","title":"Join Relations","text":"<ul> <li>Join type:</li> </ul> <ul> <li>defines how tuples in each relation that do not match any tuple in the other relation (based on the join condition) are treated.</li> </ul> <ul> <li>join condition:</li> </ul> <ul> <li>defines which tuples in the two relations match, and what attributes are present in the result of the join.</li> </ul> course natural right outer join prereqcourse natural full outer join prereqcourse full outer join prereq using (couse_id)course inner join prereq on course.course_id = prereq.course_idcourse left outer join prereq on course.course_id = prereq.course_id <p>SQL<pre><code>SELECT *  \nFROM course NATURAL RIGHT OUTER JOIN prereq;  \n</code></pre> * keep all prereq tuples  </p> <p>SQL<pre><code>SELECT *  \nFROM course NATURAL FULL OUTER JOIN prereq;  \n</code></pre> * keep all course and prereq tuples   </p> SQL<pre><code>SELECT *  \nFROM course FULL OUTER JOIN prereq USING (course_id);  \n</code></pre> SQL<pre><code>SELECT *  \nFROM course INNER JOIN prereq ON course.course_id = prereq.course_id;  \n</code></pre> SQL<pre><code>SELECT *  \nFROM course LEFT OUTER JOIN prereq ON course.course_id = prereq.course_id;  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#transactions","title":"Transactions","text":"<ul> <li>commit work </li> <li>rollback work </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#views","title":"Views","text":"<ul> <li>to disguise certain daya from the view of certain users    </li> <li>create view </li> </ul> SQL<pre><code>   create view faculty as  \n     select *  \n     from instructor  \n</code></pre> <ul> <li> <p>then we can use it</p> </li> <li> <p>views can be defined by other views  </p> </li> <li>updates of a view  </li> <li>Most SQL implementations allow updates only on simple views </li> </ul> <ul> <li>materialized view </li> </ul> <ul> <li>create a physical table containing all the tuples in the result of the query defining the view</li> </ul> <ul> <li>index creation:   </li> </ul> SQL<pre><code>create index idx_course_id on course(course_id);  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#integrity-constraints","title":"Integrity Constraints","text":"<ul> <li>not null</li> </ul> SQL<pre><code>name varchar(20) not null\nbudget numeric(12,2) not null\n</code></pre> <ul> <li>primary key</li> <li>unique</li> </ul> <p>form a candidate key, permit nulls, unlike primary key</p> <ul> <li>check(p)</li> </ul> <p>where P is a predicate. Specifies a predicate P that must be satisfied by every tuple in a relation.</p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#referential-integrity","title":"Referential Integrity","text":"<ul> <li>cascade</li> </ul> <ul> <li>delete cascade: delete all tuples in the referencing relation</li> <li>update cascade: update all foreign keys in the referencing relation</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#complex-check-clauses","title":"Complex Check Clauses","text":"<ul> <li>subquery in check clause not supported by pretty much any database</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#user-defined-types","title":"User-Defined Types","text":"SQL<pre><code>create tyoe Dollars as numeric (12,2) final;\n</code></pre> <ul> <li>domains:</li> </ul> <p>a type with constraints</p> SQL<pre><code>create domain degree_level varchar(10)\nconstraint degree_level_constaint\ncheck (value in ('Bachelors', 'Masters', 'Doctorate'));\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#large-object-types","title":"large-object types","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#authorization","title":"Authorization","text":"<ul> <li>grant:</li> </ul> SQL<pre><code>grant &lt;privilege list&gt;\non &lt;relation name or view name&gt;\nto &lt;user list&gt;\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#revoking-authorization","title":"Revoking Authorization","text":"SQL<pre><code>revoke &lt;privilege list&gt;\non &lt;relation name or view name&gt;\nfrom &lt;user list&gt;\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Four/#role","title":"role","text":"<ul> <li>a role is a way to distinguish among users as far as what these users can access/update in the database</li> </ul> SQL<pre><code>create role &lt;name&gt;\ngrant &lt;role&gt; to &lt;users&gt;\n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/","title":"Index","text":"<p>Basic Concepts</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/#primary-index","title":"Primary Index","text":"<ul> <li>index sequence is equal to the key sequence</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/#secondary-index","title":"Secondary Index","text":"<p>Example</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/#dense-index-files","title":"Dense INdex Files","text":"<p>Note</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/#sparse-index-files","title":"Sparse Index Files","text":"<p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/#multilevel-index","title":"Multilevel Index","text":"<p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Fourteen/#b-tree","title":"B+ Tree","text":"<ul> <li>If there are K search-key values in the file, the tree height is no more than \\(\\lceil \\log_{n/2} K \\rceil\\). searches can be conducted efficiently.</li> </ul> LessCss<pre><code>C=root\nWhile C is not a leaf node {\n Find the minimum i s.t. V &lt;= Ki. //find from left to right in the node\n If found { if (V= Ki ) Set C = Pi +1 else set C = Pi} \n Else set C = last non-null pointer in C\n}\n//now go to the leaf node and search in the leaf node\nFind the minimum i s.t. Ki = V\nIf found, follow pointer Pi to the desired record.\nElse no record with search-key value k exists.\n</code></pre> <ul> <li> <p>A node is generally the same size as a disk block, typically 4 kilobytes</p> </li> <li> <p>n is typically around 100 (40 bytes per index entry).</p> </li> <li> <p>The height of the tree is no more than \\(\\lceil \\log_{n/2} K \\rceil\\).</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_One/","title":"Introduction","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_One/#intro","title":"Intro","text":"<ul> <li>Basically, there are two modes in which databases are used <p>Online Transaction Processing: a large number of users use the database, with each user retrieving relatively small amounts of data, and performing small updates.  data analytics: processing of data to draw conclusions, and infer rules or decision procedures, which are then used to drive business decisions.    </p> </li> <li>The field of data mining combines knowledge-discovery techniques invented by artificial intelligence researchers and statistical analysts with efficient implemen tation   </li> <li>The field of data mining combines knowledge-discovery techniques invented by artificial intelligence researchers and statistical analysts with efficient implemenatation techniques that enable them to be used on extremely large databases.  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_One/#file-processing-systemssupported-by-a-conventianal-operating-system","title":"File-Processing Systems(supported by a conventianal operating system)","text":"<ul> <li>Majarity Disadvantages:   <p>Data redundancy and inconsistency Difficulty in accessing data: t conventional file-processing environments do not allow needed data to be retrieved in a convenient and efficient manner. More responsive data-retrieval systems are required for general use.  </p> </li> </ul> <p>Data isolation: because data are scattered in various files, and files may be in different formats, writing new application programs to retrieve the appropriate data is difficult.  </p> <p>Integrity problems: The data values stored in the database must satisfy certain types of consistency constraints. However, when new constraints are added, it is difficult to change the programs to enforce them. The problem is compounded when constraints involve several data items from different files  </p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/","title":"Chapter Seven","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#functional-dependencies","title":"Functional Dependencies","text":"<ul> <li> <p>K is a superkey of relation R if and only if K-&gt;R</p> </li> <li> <p>candidate key</p> </li> </ul> <p>K-&gt;R for no proper subset K' of K, K'-&gt;R is true</p> <ul> <li> <p>a bad relationship: exist an attribute A in R such that K-&gt;attribute yet K is not i n a superkey of R</p> </li> <li> <p>trivial functional dependency:</p> </li> </ul> <p>K-&gt;A is trivial if A is a subset of K</p> <ul> <li> <p>Closure</p> <p>The closure of a set of attributes K with respect to a set of functional dependencies F, denoted by F+, is the set of all attributes that are functionally determined by K under F. A-&gt;b, b-&gt;c, then A-&gt;c is a functional dependency in F+</p> </li> <li> <p>\u516c\u7406\u7cfb\u7edf</p> </li> </ul> <ol> <li>reflexivity:     if Y is a subset of X, then X-&gt;Y</li> <li>augmentation:    if X-&gt;Y, then XZ-&gt;YZ for any Z</li> <li>transitivity:    if X-&gt;Y and Y-&gt;Z, then X-&gt;Z</li> </ol> <p>Example</p> <p> * ab-&gt;cb is equal to av-&gt;c</p> <p>\\(A^+\\)</p> <ul> <li>\\(A^+\\) is the closure of A with respect to F, the attributes it can determine</li> </ul> <p>pseoducode</p> <p></p> <ul> <li>\u5176\u5b9e\u672c\u8d28\u4e0a\u5c31\u662f\u4e00\u4e2a\u6709\u5411\u56fe</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#uses-of-attribute-closure","title":"Uses of Attribute Closure","text":"<ul> <li> <p>testing superkey</p> </li> <li> <p>testing function dependencies</p> </li> <li> <p>compute closure of F</p> </li> </ul> <p>compute the closure of all the subset of F compute the subset of the determinants of all the subset of F</p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#canonical-cover","title":"Canonical Cover\u6b63\u5219\u8986\u76d6","text":"<p>Explanation and Definition</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#extraneous-attributes","title":"Extraneous Attributes\u65e0\u5173\u5c5e\u6027","text":"<p>Explanation and Definition</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#boyce-codd-normal-form-bcnf","title":"Boyce-Codd Normal Form (BCNF)","text":"BCNF DefinitionImplementation <p>definition</p> <p></p> <p>pseudocode</p> <p></p> <ul> <li>decomposing a schema into BCNF</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#dependency-preservation","title":"Dependency Preservation","text":"<ul> <li>a decomposition of relation R into relations R1, R2, ..., Rn is dependency preserving if every functional dependency in F+ can be enforced by a set of functional dependencies on the relations R1, R2, ..., Rn</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Seven/#third-normal-form-3nf","title":"Third Normal Form (3NF)","text":"3NF DefinitionImplementation <p>definition</p> <p></p> <p>pseudocode</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/","title":"Data Storage Structures","text":"<ul> <li>database are stored as files, files are stored as seqeuential records, and records are stored as sequential fields</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#fixed-length-records","title":"Fixed-Length Records","text":"<ul> <li>Deletion:</li> </ul> <p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#variable-length-records","title":"Variable-Length Records","text":"<ul> <li>null-value bitmap</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#slotted-page","title":"Slotted Page","text":"<p>Structure</p> <p></p> <ul> <li>When deletion, set to null</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#organization-of-records-in-files","title":"Organization of records in Files","text":"<ul> <li> <p>Heap</p> </li> <li> <p>Sequential</p> </li> <li> <p>in a multitable clustering file organization: records of several different relations can be stored in the same file</p> </li> <li> <p>B+ tree</p> </li> </ul> <p>records are stored in leaf nodes, and the internal nodes are used to direct the search</p> <ul> <li>hashing</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#heap","title":"Heap","text":"<ul> <li>Free-spaced map</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#sequential","title":"Sequential","text":"<ul> <li>difficult to insert and delete, therefore use pointer</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#multitable-clustering-help-joining","title":"Multitable clustering: help joining","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#table-partitioning","title":"Table Partitioning","text":"<ul> <li>hel single-fetch</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#data-dictionary-storage","title":"Data dictionary storage","text":"<p>Note</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#lru","title":"LRU","text":"<ul> <li>use a queue, the recent access one,  put the first</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#clock-an-approximation-to-lru","title":"Clock: An Approximation to LRU","text":"<ul> <li> <p>use a circular queue, and a reference bit</p> </li> <li> <p>unpin: reference_bit=1, which can be replaced</p> </li> <li> <p>when encountered a reference_bit=1, set to zero when used</p> </li> <li> <p>when encountered a reference_bit=0, replace it</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Thirteen/#column-oriented-storage","title":"Column Oriented Storage","text":"<p>Note</p> <p> * really good at analysis, as analysis require heavily on a single column </p> <ul> <li>cash-aware storage</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/","title":"Introduction to SQL","text":"<ul> <li>SQL : define the structure of the data, modify data in the database, and specify security constraints.</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#overview-of-the-sql-query-language","title":"Overview of the SQL Query Language","text":"<ul> <li>Data-definition language (DDL):The SQL DDL provides commands for defining relation schemas, deleting relations, and modifying relation schemas.  </li> <li>Data-manipulation language (DML): The SQL DML provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database.  </li> <li>Integrity </li> <li>View Definition </li> <li>Transaction Control </li> <li> <p>Embedded SQL and Dynamic SQL </p> </li> <li> <p>Authorization </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#32-sql-data-definition","title":"3.2 SQL Data Definition","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#321-basic-types","title":"3.2.1 Basic Types","text":"<ul> <li>CHAR(n): A fixed-length string of n characters. The full form, CHARACTER(n), is also supported.  </li> <li>VARCHAR(n): A variable-length string with a maximum size of n characters. The full form, CHARACTER VARYING(n), is also supported.  </li> <li>INT: A 4-byte integer. The full form, integer, is also supported.  </li> <li> <p>SMALLINT: A small integer.     </p> </li> <li> <p>NUMERIC(p,d): A fixed-point number with p digits(plus a sign), d of which are to the right of the decimal point.   </p> </li> <li> <p>REAL, DOUBLE PRECISION: Floating-point numbers.  </p> </li> <li> <p>FLOAT(n): A floating-point number with at least n bits of precision.  </p> </li> <li> <p>NULL: The null value.    </p> </li> </ul> varchar and charusage <p>Note</p> <p>The char data type stores fixed-length strings. Consider, for example, an attribute A of type char(10). If we stored a string \u201cAvi\u201d in this attribute, seven spaces are appended to the string to make it 10 characters long. In contrast, if attribute B were of type varchar(10), and we stored \u201cAvi\u201d in attribute B, no spaces would be added. When comparing two values of type char, if they are of di\ufb00erent lengths, extra spaces are automatically attached to the shorter one to make them the same size before comparison. <p>Note</p> <p>As a result, even if the same value \u201cAvi\u201d is stored in the attributes A and B above, a comparison A=B may return false. It is recommended to always use the varchar type instead of the char type to avoid these problems. <p>Tip</p> <p>SQL also provides the nvarchar type to store multilingual data using the Unicode representation. However, many databases allow Unicode (in the UTF-8 representation) to be stored even in varchar types."},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#322-basic-schema-definition","title":"3.2.2 Basic Schema Definition","text":"<ul> <li>create table: We define an SQL relation by using the create table command.  </li> </ul> <p>code</p> SQL<pre><code>create table department  \n   (  \n    dept_name varchar(20),  \n    building varchar(15),  \n    budget numeric(12,2),  \n    primary key (dept_name)\n   );  \n</code></pre> <ul> <li>integrity constraints:  <ul> <li>primary key: the primary -key attributes</li> <li>foreign key + references:  Some   database systems, including MySQL, require an alternative syntax, \u201cforeign key (dept name) references department(dept name)\u201d, where the referenced attributes in the referenced table are listed explicitly.    </li> <li>not null: <code>&lt;attribute&gt; &lt;type&gt; not null</code> he constraint excludes the null value from the domain of that attribute.   </li> </ul> </li> </ul> <p>Attention</p> <p>SQL prevents any update to the database that violates an integrity constraint. If violates, SQL flags an error and prevents the update. <ul> <li><code>drop table</code>: delete a relation</li> </ul> <p>Comparison</p> <p> <code>drop table r</code> deletes the whole schema, including all tuples in the relation r. <code>delete from r</code> deletes all the tuples, yet retains relation r <ul> <li><code>alter table</code>: add attributes to an existing relation. All tuples in the relation are assigned null as the value for the new attribute. <code>alter table r add A D;</code> A is the name of the attribute to be added, and D is the type of the added attribute. Thus, <code>alter table r drop A;</code> deletes attribute A from relation r. To be aware, many database systems do not support dropping of attributes.  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#33-basic-structure-of-sql-queries","title":"3.3 Basic Structure of SQL Queries","text":"<p>The basic structure of an SQL query consists of three clauses: select, from, and where. A query takes as its input the relations listed in the from clause, operates on them as specified in the where and select clauses, and then produces a relation as the result. </p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#331-queries-on-a-single-relation","title":"3.3.1 Queries on a Single Relation","text":"<ul> <li>select distinct: In practice, duplicate elimination is time-consuming. Therefore, SQL allows duplicates in database relations as well as in the results of SQL expressions.1 Thus, the preceding SQL query lists each department name once for every tuple in which it appears in the instructor relation.  </li> <li> <p>select all: SQL allows us to use the keyword all to specify explicitly that duplicates are not removed  </p> </li> <li> <p>The select clause may also contain arithmetic expressions involving the operators <code>+</code>,<code>\u2212</code>, <code>\u2217</code>, and <code>/</code> operating on constants or attributes of tuples.  </p> </li> <li> <p>where: SQL allows the use of the logical connectives and, or, and not in the where clause. The operands of the logical connectives can be expressions involving the comparison operators &lt;, &lt;=, &gt;, &gt;=, =, and &lt;&gt;. SQL allows us to use the comparison operators to compare strings and arithmetic expressions, as well as special types, such as date types.  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#332-queries-on-multiple-relations","title":"3.3.2 Queries on Multiple Relations","text":"<ul> <li> <p>Natural Join:   SQL<pre><code>select name, course_id  \nfrom instructor natural join teaches;  \n</code></pre> \\(instructor \\bowtie teaches\\) </p> <p>Danger in natural join natural join may provide more constraints </p> </li> <li> <p>Rename:   </p> <p>the <code>as</code> clause  </p> </li> </ul> as in selectas in from SQL<pre><code>select ID, name, salary/12 as monthly_salary  \nfrom instructor;  \n</code></pre> SQL<pre><code>select distinct T.name  \nfrom instuctor as T, instructor as S  \nwhere T.salary&gt;S.salary and S.dept_name='Comp. Sci.';  \n</code></pre> <ul> <li> <p>Keyword as is optional and may be omitted. </p> <p>instructor as T = instructor T   Keyword as must be omitted in Oracle  </p> </li> <li> <p>string operations </p> <p>SQL includes a string-matching operator for comparisons on character strings.  The operator \u201clike\u201d uses patterns that are described using two special characters:    * <code>%</code>: matches any substring of zero or more characters.    * <code>_</code>: matches any single character.  </p> </li> </ul> examplewhen we want to match the character % or _ SQL<pre><code>select name    \nfrom instructor  \nwhere name like '%dar%';  \n</code></pre> SQL<pre><code>select name  \nfrom instructor  \nwhere name like '%\\%%' escape '\\';  \n</code></pre> <ul> <li>Ordering the display of tuples:  </li> <li>order by: in alphabetical order  </li> </ul> <p>SQL<pre><code>select name  \nfrom instructor  \norder by name;  \n</code></pre>    * We may specify desc for descending order or asc for ascending order, for each attribute; ascending order is the default. <code>order by name desc</code>    * can sort on multiple attributes   <code>order by dept_name, name</code> </p> <ul> <li> <p>Specific where clause predicates </p> <p>between SQL<pre><code>select name \nfrom instructor  \nwhere salary between 90000 and 100000;  \n</code></pre> tuple comparison SQL<pre><code>select name, course_id  \nfrom instructor, teaches  \nwhere (instructor.ID, dept_name) = (teaches.ID, 'Biology');  \n</code></pre></p> </li> <li> <p>set operations </p> <p>union SQL<pre><code>(select course_id from section where sem = \u2018Fall\u2019 and year = 2009) union (select course_id from section where sem = \u2018Spring\u2019 and year = 2010)  \n</code></pre> intersect except Each of the above operations automatically eliminates duplicates</p> </li> <li> <p>To retain all duplicates use the corresponding multiset versions union all, intersect all and except all.  </p> </li> <li> <p>Null Values:  </p> <ul> <li>It is possible for tuples to have a null value, denoted by null, for some of their attributes</li> </ul> </li> </ul> <ul> <li> <p>The result of any arithmetic expression involving null is null</p> </li> <li> <p>The predicate  is null can be used to check for null values.</p> </li> </ul> <ul> <li>(unknown or true) = true, (unknown or false) = unknown, (unknown or unknown) = unknown </li> <li>(unknown and true) = unknown, (unknown and false) = false, (unknown and unknown) = unknown </li> <li>(not unknown) = unknown </li> <li><code>P is unknown</code> evaluates to true if predicate P evaluates to unknown.  </li> <li> <p>Result of where clause predicate is treated as false if it evaluates to unknown  </p> </li> <li> <p>Aggregate Functions:  </p> <p>group by having: after group by  </p> </li> <li> <p>NULL:  </p> <p>all aggregate operations except count(*) ignore tuples with null values on the aggregated attribute.  </p> </li> </ul> <p>What if collection has only null values? * count(*) returns 0  * all other aggregates return null   </p> <ul> <li>Nested Subqueries:   </li> </ul> <ul> <li>A subquery is a select-from-where expression that is nested within another query.   in: SQL<pre><code>select distinct course_id  \nfrom section  \nwhere semester = 'Fall' and year = 2009 and course_id in (select course_id from section where semester = 'Spring' and year = 2010);  \n</code></pre></li> </ul> <ul> <li>some:  </li> </ul> SQL<pre><code>select name  \nfrom instructor  \nwhere salary &gt; some (select salary from instructor where dept_name = 'Biology');  \n</code></pre> <p>=some is equivalent to the keyword in  yet not some is not equalvalent to not in  </p> <ul> <li> <p>all: SQL<pre><code>select name  \nfrom instructor  \nwhere salary &gt; all (select salary from instructor where dept_name = 'Biology');  \n</code></pre></p> <p>salary of the instructor is greater than all the salaries of instructors in the Biology department. *!all is equalvalent to !in    </p> </li> <li> <p>test for empty relations </p> <ul> <li>exists: SQL<pre><code>select name from instructor where exists (select * from advisor where advisor.ID = instructor.ID);  \n</code></pre> in a nested subquery, an attribute can be fetched from the outer query.   SQL<pre><code>select distinct course_id  \nfrom section as S  \nwhere semester='Fall' and year=2009 and not exists (select * from section as T where semester='Spring' and year=2010 and S.course_id=T.course_id);  \n</code></pre></li> </ul> </li> </ul> <ul> <li>nstructor.ID  and S.course_id  are attributes that are not in the relation of the subquery, they are called correlation variables     </li> </ul> <ul> <li> <p>not exists to realize division SQL<pre><code>select S.ID, S.name  \nfrom student S  \nwhere not exists((select course_id from section where dept_name='Biology') except (select course_id from takes as T where T.ID = S.ID));  \n</code></pre></p> </li> <li> <p>test for absence of duplicate tuples SQL<pre><code>select T.course_id  \nfrom course as T  \nwhere unique (select R.course_id  \nfrom section as R  \nwhere R.course_id = T.course_id and R.year = 2009);  \n</code></pre></p> <p>evaluates to 'true' on an empty set  </p> </li> <li> <p>subqueries in the from clause SQL<pre><code>select dept_name, avg_salary  \nfrom (select dept_name, avg(salary) as avg_salary  \n      from instructor  \n      group by dept_name)  \nwhere avg_salary &gt; 42000;  \n</code></pre></p> </li> <li> <p>with clause:  </p> <p>The with clause provides a way of defining a temporary view whose definition is available only to the query in which the with clause occurs. </p> </li> </ul> SQL<pre><code>with max_budget(value) as \n(select max(budget) from department) select dept_name \nfrom department,max_budget  \nwhere department.budget = max_budget_value;   \n</code></pre> <ul> <li> <p>complex queries using with clause: SQL<pre><code>with dept_total(dept_name, value) as  \n(select dept_name, sum(salary)  \n from instructor  \n group by dept_name)  \ndept_total_avg(value) as  \n(select avg(value)  \n from dept_total)  \nselect dept_name  \nfrom dept_total, dept_total_avg  \nwhere dept_total.value &gt; dept_total_avg.value;  \n</code></pre></p> </li> <li> <p>scalar subquery: SQL<pre><code>select dept_name  \nfrom department  \nwhere budget = (select max(budget) from department);  \n</code></pre></p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Three/#modification-of-the-database","title":"Modification of the Database","text":"<ul> <li>deletion:  </li> </ul> <p>delete from delete from instructor where dept_name='Finance';  </p> <ul> <li>insert one row:  </li> </ul> add a new tupleadd a new tuple to student with tot_creds set to nulladd all instructors to the instructor table SQL<pre><code>insert into course  \n    values('CS-437', 'Database Systems', 'Comp. Sci.', 4);  \n</code></pre> SQL<pre><code>insert into student  \n    values('3003', 'Green', 'Finance', null);  \n</code></pre> <p>SQL<pre><code>insert into instructor  \n    select * from instructor_temp;  \n</code></pre> * The select from where statement is evaluated fully before any of its results are inserted into the relation  </p> <ul> <li>updates </li> </ul> setset multiple attributescaseupdates with scalar subqueries SQL<pre><code>update instructor  \nset salary = salary * 1.10  \nwhere dept_name = 'Physics';  \n</code></pre> SQL<pre><code>update instructor  \nset salary = salary * 1.10, dept_name = 'Finance'  \nwhere dept_name = 'Physics';  \n</code></pre> SQL<pre><code>update instructor  \nset salary = case  \n                when salary &lt; 100000 then salary * 1.10  \n                else salary*1.03 \n             end;  \n</code></pre> SQL<pre><code>update student S  \n  set tot_cred = (select sum(credits)  \n                  from takes natural join course \n                  where S.ID=takes.ID and takes.grade &lt;&gt; 'F' and takes.grade is not null);  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/","title":"Physical Storage Systems","text":""},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/#magnetic-disk","title":"Magnetic Disk","text":"<ul> <li>Read-Write head</li> </ul> <ul> <li> <p>reads or writes magnetically encoded information</p> </li> <li> <p>surface of platter divided into circular tracks</p> </li> <li> <p>track is divided into sectors</p> </li> <li> <p>Sector size typically 512 bytes Typical sectors per track: 500 to 1000 (on inner tracks) to 1000 to 2000 (on outer tracks)</p> </li> <li> <p>To read and write a sector</p> </li> </ul> <ul> <li>Disk Controller: interfaces between the computer system and the disk drive hardware.</li> </ul> <ul> <li>initiates actions such as moving the disk arm to the right track and actually reading or writing the data</li> <li> <p>Computes and attaches checksums to each sector to verify that data is read back correctly</p> <ul> <li>If data is corrupted, with very high probability stored checksum won\u2019t match recomputed checksum</li> </ul> </li> <li> <p>Ensures successful writing by reading back sector after writing it</p> </li> <li> <p>Performs remapping of bad sectors</p> </li> </ul> <ul> <li>Performance Measures of Disks</li> </ul> <ul> <li> <p>Access Time: the time it takes from when a read or write request is issued to when data transfer begins  </p> </li> <li> <p>Seek Time: time it takes to reposition the arm over the correct track. </p> </li> <li>Average seek time is \u00bd the worst case seek time.</li> <li> <p>Would be \u2153 if all tracks had the same number of sectors, and we ignore the time to start and stop arm movement</p> </li> <li> <p>4 to 10 milliseconds on typical disks</p> </li> <li> <p>Rotational latency: time it takes for the sector to be accessed to appear under the head.</p> </li> <li> <p>Average latency is \u00bd of the worst case latency.</p> </li> <li> <p>4 to 11 milliseconds on typical disks (5400 to 15000 r.p.m.)</p> </li> <li> <p>Data transfer rate: the rate at which data can be retrieved from or stored to the disk.</p> </li> <li>25 to 200 MB per second max rate, lower for inner tracks</li> <li> <p>Multiple disks may share a controller, so rate that controller can handle is also important</p> </li> <li> <p>Disk Block: a logical unit for storage allocation and retrieval</p> </li> <li>Smaller blocks: more transfers from diskDisk </li> <li> <p>Larger blocks: more space wasted due to partially filled blocks</p> </li> <li> <p>Sequential access pattern:</p> </li> <li>Successive requests are for successive disk blocks</li> <li> <p>Disk seek required only for first block</p> </li> <li> <p>Random access Pattern:</p> </li> <li>Successive requests are for blocks that can be anywhere on disk</li> <li> <p>Because of the fact that each access required a seek, transfer rates are low since a lot of time is wasted in seeks</p> </li> <li> <p>I/O operations per second (IOPS)</p> </li> <li> <p>Number of random block reads that a disk can support per second</p> </li> <li>50 to 200 IOPS on current generation magnetic disks</li> <li>MTTF(Mean time to failure):  the average time the disk is expected to run continuously without any failure.</li> <li>Typically 3 to 5 years</li> <li>MTTF decreases as disk ages</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/#flash-storage","title":"Flash Storage","text":"<ul> <li>NAND flash</li> </ul> <ul> <li> <p>used widely for storage, cheaper than NOR flash</p> </li> <li> <p>requires page-at-a-time read</p> </li> <li>20 to 100 microseconds for a page read</li> <li> <p>Not much difference between sequential and random read</p> </li> <li> <p>Page can be writtem once</p> </li> <li>Must be erased to allow rewrite</li> </ul> <ul> <li>Solid state disks</li> </ul> <ul> <li> <p>Use standard block-oriented disk interfaces, but store data on multiple flash storage devices internally</p> </li> <li> <p>Transfer rate of up to 500 MB/sec using SATA, and up to 3 GB/sec using NVMe PCIe</p> </li> <li> <p>Erase happens in units of erase block</p> </li> <li>Takes 2 to 5 millisecs</li> <li>Erase block typically 256 KB to 1 MB (128 to 256 pages)</li> </ul> <ul> <li>Remapping</li> </ul> <ul> <li>Remapping of logical page addresses to physical page addresses avoids waiting for erase</li> <li> <p>Flash translation table</p> </li> <li> <p>also stored in a label field of flash page</p> </li> <li> <p>remapping carried out by flash translation layer</p> </li> </ul> <ul> <li>Flash translation table</li> </ul> <ul> <li>also stored in a label field of flash page</li> <li>remapping carried out by flash translation layer</li> </ul> <ul> <li>Wear Levelling</li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/#ssd","title":"SSD","text":"<ul> <li> <p>Random reads/writes per second</p> <ul> <li>Typical 4KB reads:  10,000 reads per second (10,000 IOPS)</li> </ul> </li> <li> <p>Typical  4KB writes: 40,000 IOPS</p> </li> <li> <p>Parallel reads:</p> <ul> <li>Typical 4KB reads:</li> </ul> <p>100,000 IOPS with 32 requests in parallel (QD-32) on SATA 350,000 IOPS with QD-32 on NVMe PCIe</p> </li> <li> <p>Data transfer rate for sequential reads and writes</p> </li> </ul> <p>400 MB/sec for SATA3, 2 to 3 GB/sec using NVMe PCIe</p> <ul> <li>Hybrid disks:</li> </ul> <p>combine small amount of flash cache with larger magnetic disk</p>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/#optimization-of-disk-block-access","title":"Optimization of Disk-Block Access","text":"<ul> <li>Buffering</li> </ul> <ul> <li>in-memory buffer to cache disk blocks</li> <li>Read-ahead: Read extra blocks from a track in anticipation of future requests</li> <li>Disk-arm scheduling: algorithms re-order block requests so that disk arm movement is minimized</li> <li>Elevator algorithm: requests are serviced in the order they arrive, but the disk arm moves in one direction until it reaches the end of the disk, then reverses direction and services requests in the opposite direction.</li> </ul> <ul> <li>File Organization</li> </ul> <ul> <li>Allocate blocks of a file in as contiguous a manner as possible</li> <li>Allocation in units of extents</li> <li> <p>Files may get fragmented</p> </li> <li> <p>if free blocks on disk are scattered, and newly created file has its blocks scattered over the disk</p> </li> <li> <p>Sequential access to a fragmented file results in increased disk arm movement</p> </li> <li> <p>Some systems have utilities to defragment the file system, in order to speed up file access</p> </li> <li> <p>Non-volatile write buffers </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/#file-organization-record-organization-and-storage-access","title":"File Organization, Record Organization and Storage Access","text":"<ul> <li>File Organization</li> </ul> <ul> <li> <p>Each file is a sequence of records.  A record is a sequence of fields.</p> </li> <li> <p>Record access is simple but records may cross blocks</p> <ul> <li>Modification: do not allow records to cross block boundaries</li> </ul> </li> <li>Deletion of Record i:<ul> <li>move records i + 1, . . ., n to i, . . . , n \u2013 1; move record n  to i; do not move records, but link all free records on afree list</li> </ul> </li> </ul> <ul> <li>Free Lists</li> </ul> <ul> <li> <p>Store the address of the first deleted record in the file header. Use this first record to store the address of the second deleted record, and so on</p> </li> <li> <p>Can think of these stored addresses as pointers since they \u201cpoint\u201d to the location of a record.</p> </li> <li> <p>More space efficient representation:  reuse space for normal attributes of free records to store pointers.  (No pointers stored in in-use records.)</p> </li> </ul> <ul> <li>Variable-Length Records</li> </ul> <p>Definition</p> <p></p> <ul> <li> <p>Null values represented by null-value bitmap</p> </li> <li> <p>Variable-Length Records: Slotted Page Structure</p> </li> </ul> <ul> <li> <p>Slotted page header contains:</p> <ul> <li>number of record entries; end of free space in the block; location and size of each record</li> </ul> </li> <li> <p>Records can be moved around within a page to keep them contiguous with no empty space between them; entry in the header must be updated.</p> </li> <li> <p>Pointers should not point directly to record \u2014 instead they should point to the entry for the record in header.</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DATABASE%20SYSTEMS/Chapter_Twelve/#storing-large-objects","title":"Storing Large Objects","text":"<ul> <li> <p>Records must be smaller than pages</p> </li> <li> <p>Buffering</p> </li> </ul> <p>Read-ahead(Pre-fetch): Read extra blocks of data into the buffer in anticipation of future requests.</p> <p>Disk-arm scheduling: algorithms re-order block requests so that disk arm movement is minimized.: Elevator algorithm</p> <ul> <li>File Organization: defragment</li> </ul> <p>Note</p> <p></p> <ul> <li>Optimization of Disk Block Access</li> </ul> <p>Non-volatile write buffers</p> <p>log disk</p> <ul> <li>flash storage</li> </ul> <p>NAND flash: non-volatile storage technology that uses memory cells made of floating-gate transistors. Page-at-a-time read, but be erased before rewrite</p> <p>SSD(Solid State Disks): a type of storage device that uses NAND flash memory to store data. block-oriented</p> <p>logic memory address: one block, when erased and written too many times, might become unusable. </p> <p>wear leveling: a technique used in SSDs to distribute write and erase cycles evenly across the memory cells to prolong the lifespan of the device.</p> <ul> <li>NVM: </li> </ul> <p>Tip</p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/","title":"Digital image processing","text":"<p>Note</p> <p>This is the fundamental course of computer graphics, taught by Prof. Mingli Song</p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/","title":"Introduction","text":""},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#digital-image-representation","title":"Digital image representation","text":"<ul> <li>Digital image: a 2D array or matrix of small elements called pixels.  </li> <li>Eachpixel in a grayscale image is represented by a byte (8 bits), which can take on 256 different intensity values.   </li> <li>A color image is represented by three bytes (24 bits) per pixel, one byte for each of the three primary colors: red, green, and blue.</li> </ul> Tip <p>Another byte called alpha, representing the transparency.RGB are stored in three distinct arrays. The sequence might be different </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#image-format","title":"Image format","text":"<ul> <li>Representative format: BMp(windows,mostly without compression), GIF, JPEG(compression with loss), PNG, TIFF, etc.   </li> <li>Characteristic of image: pixel based, rectangle region, with information stored  </li> <li> <p>Encoding method: without compression, with loss, with lossless, etc.  </p> </li> <li> <p>BMP format:  </p> </li> <li>One of the standard formats for storing bit-mapped images on Microsoft Windows systems.  </li> <li>sometimes saved as .dib  </li> <li>mostly organized in a non-compressed way.  </li> <li> <p>can be compressed though  </p> </li> <li> <p>BMP file structure:  </p> </li> <li>File header: 14 bytes, containing information about the type, size, and layout of the file.  </li> <li>Info header: 40 bytes, containing information about the image, such as its width, height, and color depth.  </li> <li>Color table: 0 or 1024 bytes, containing the colors used in the image.  </li> <li>Pixel data: the actual image data.  </li> <li>Palette: a table of colors used by the image.(not used right now, was used to save space(for those monitors with limited color display))   </li> <li>image data: color greyscale image(if you want to convert a 24-bit image to a greyscale image,set the R G B data of every pixel to one number)   </li> </ul> <p>Tip</p> <p>bfOffBits stores the offset from beginning of the file to bitmap data, therefore if you don't want to alter the bitmap information header,use this.  </p> <p>  * a few things that worth a notice: bisize: the bytes of BITMAPINFOHEADER biheight: if positive: inverted           else: upright bibitcount; the number o bits used to store one pixel biXPelsPerMeter: the size of pixel(number of pixels per meter)(horizonal)  </p> <p>possible usage in daily life</p> <p>Embed picture in essays, How much dpi?(shall be elevated to be professional,keep the balance between size and clarity)</p> <p>  whether it is inverted or not, one shall be cautious </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#basic-principle-of-imaging","title":"Basic principle of imaging:","text":"<p>___imitate an eye__ what is the suitable size of the aperture? * too big: \u865a\u5316 * too small: clear yet not bright enough and \u884d\u5c04  * Lens *    Both aperture and depth of field can effect the circle of confusion Lens Group: f can be changed  </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#digital-camera","title":"Digital Camera","text":"<ol> <li>CCD:  Charge Coupled Device: Now we use CMOS more often photodiode: stimulated to release charges, and produces electrical signals  </li> </ol> <p>Amplifier 2. AD: 3. DSP: digital image processor (worth doing)  4. Mermory    </p> <p></p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#physicsal-meaning-of-color","title":"Physicsal meaning of color","text":"<p> Dichromatic Reflection Separation:  * Specular reflection: mirror reflection * Diffuse reflection: scattering reflection    </p> <p>dealing with the reflection of light, the color of the object is determined by the light source and the object itself.  </p> <p>Color can be divided into chromatic color and achromatic color(no color). * Chromatic color: the color of the object itself. </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#three-primary-colors","title":"Three-primary colors","text":"<ul> <li>RGB: additive color mixing  R: 700nm G: 546.1nm B: 435.8nm human eyes can see far more colors than colors generated by normal monitors  </li> </ul> <p>Tip</p> <p>Absolute color vision is not precise: human identifies color by visual context(comparing) </p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#properties-of-color-vision","title":"Properties of color vision","text":"<ul> <li>Perceptive ability:  different people have different Webber's Law: the difference between two colors is proportional to the background.  Priority: first the hue(\u8272\u8c03) changes, saruration(\u9971\u548c\u5ea6) changes, then the brightness changes.  Sensitivity: human eyes are the most sensitive to the lightness changes and have the best resolution, which is responsible for the eyes' HDR capacity device dependent color space model: RGB, CMY, YUV, YIQ, YCbCr, HSV, HSL, etc. device independent color space model: CIE XYZ, CIE Lab, CIE Luv, etc.  </li> </ul> <p>Why independent?</p> <p>the color space model should be independent of the device to convert image data to various devices </p> <p>RGB color model  * RGB is a subset of CIE primary color space * TV, Phones  </p> <p>CMY color model  * delete the color that is not needed(main idea) * printer  </p> <p>Note</p> <p>C,M,Y,K(black)to save money while printing </p> <p>subtractive color mixing(cmy)/ additive color mixing(rgb)  </p> <p>HSV color model  Adantage of HSV color model:  more efficient and precise when altering pictures CIE XYZ XYZ follows three-primary color theory has direct relationship with RGB monitors CIE Lab CIE YUV </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#jpeg-format","title":"JPEG format","text":"<ul> <li>Joint Photographic Experts Group  </li> <li>Founded in 1986, presented the first standard in 1992, accepted by ISO in 1994  </li> <li>File extension: .jpg, .jpeg, .jpe, .jfif  </li> <li>Compression format for static image  </li> <li>Lossy compression  </li> <li>Encoding based on transformation  <ul> <li>DCT(Discrete Cosine Transform)(\u79bb\u6563\u4f59\u5f26\u53d8\u6362\uff0c\u5229\u7528\u4fe1\u606f\u51fa\u73b0\u7684\u9891\u7387\u6765\u51b3\u5b9a\u538b\u7f29\u7684\u7a0b\u5ea6) </li> </ul> </li> </ul> <p>Note</p> <p>.jpeg can also be used in video compression, when the background of the video is not moving, the video can be compressed by jpeg.(H264) </p> <ul> <li>JPEG2000 is baes on wavelet(\u5c0f\u6ce2\u53d8\u6362\uff0c\u66fe\u4e0e\u6df1\u5ea6\u5b66\u4e60\u4e00\u822c\u706b)  </li> <li>Different manipulationd for high-frequency signal and low frequency signal\uff08\u6709\u70b9\u50cf\u970d\u592b\u66fc\u7f16\u7801\uff09    </li> <li> <p>high frequency signal   </p> </li> <li> <p>Compression strategy: set a compression ratio,remove information from high frequency to low frequency  </p> </li> <li>JPEG advantages:  </li> <li>High frequency information occupies much more memmory. Hence, high frequency removal leads to high compression ratio  </li> <li>Low frequency information preserves the principle structure and color distribution of object, which is the key factors of an image  </li> <li>suitabe for internet based visual media  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#jpeg-syntaxjust-for-acknowledgement","title":"JPEG syntax(just for acknowledgement)","text":"<p> DQT: DCT changes, quantization to a table(rounding) DHT: Huffman coding(a tree or a priority queue or trees)</p> <p> APP0 Marker  APP1 Marker: EXIF use APP1 to store meta data \u5982\u80cc\u666f\u865a\u5316\u53ef\u4ee5\u901a\u8fc7\u5149\u5708\u5927\u5c0f\u548c\u7126\u8ddd ISO\uff08\u611f\u5149\u5ea6\uff09\u7684\u6570\u503c\u8d8a\u5927\uff0c\u5149\u611f\u5ea6\u8d8a\u9ad8\uff0c\u4f46\u662f\u566a\u70b9\u4e5f\u4f1a\u589e\u52a0  \u5feb\u95e8\u901f\u5ea6\u4e0d\u80fd\u592a\u6162\uff0c\u5426\u5219\u4f1a\u6a21\u7cca motion blur might occur  Quantization table: quantize the high frequency region  DPCM encoding:    the evaluation of the quality of the image has its own regulations JPEG disadvantage * Nort for line drawing, text, symbol, icon, etc. * its lossy  compression leafs to unavoidable artifacts  </p> <p>Warning</p> <p>Do not use it in essays </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#tiff-format","title":"TIFF format","text":"<p> some public rules,and some private sections  characteristic  Basic TIFF sturcture:  mono: greyscale  </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#gif-examples","title":"GIF examples","text":"<p>Graphics Interchange Format encoding method: LZW </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#image-processing-data-structure","title":"Image processing data structure","text":"<ul> <li>Matrices</li> <li>Chains  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#matrics","title":"Matrics","text":"<p>matics of different resolution  to calculate the length between two images different rows are different channels  </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#chains","title":"Chains","text":"<p>chains are used for description of object borders avoid sparse matrics  </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#windows-apis-for-accessing-images","title":"Windows APIs for accessing images","text":"S<pre><code>#include &lt;windows.h&gt;  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#matlab-image-processing-toolbox","title":"Matlab image processing toolbox","text":"<ul> <li>Image processing toolbox How amazing!!! </li> <li>main contents </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#adobe-photoshop","title":"Adobe Photoshop","text":"<ul> <li>Function: professional software for image processing  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#gimp","title":"GIMP","text":"<ul> <li>Function: open source software for image processing has source code, supporting linux and windows  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_One/#shadow-magic-hands","title":"Shadow magic hands","text":"<ul> <li>a photo quality enhancement and personalization software  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_Two/","title":"Binary Image Processing","text":""},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_Two/#binary-image","title":"Binary image","text":"<ul> <li>Binary image:  <ul> <li>0: black  </li> <li>1: white (255)  </li> </ul> </li> </ul> <p>advantages  * less memory  * easy to process  * can sometimes be applied on grayscale image  * more cheap </p> <p>disadvantage * application field is limited * cannot be applied on D data * less expressive force, fial to express the color and gray level of the image  </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_Two/#acquisiton-of-binary-image","title":"Acquisiton of binary image","text":"<ul> <li>Thresholding: \\(I(x,y)=0 if I(x,y)&lt;Threshold\\) \\(I(x,y)=255 if I(x,y)&gt;=Threshold\\) </li> </ul> <p>How to find a good threshold?</p> <p>\u5927\u6d25\u7b97\u6cd5 </p> <p>Matlab<pre><code>    img=imread('INPUT_FILE.bmp'); \n\n    gray_img=rgb2gray(img);  \n    binary_img=imbinarize(gray_img); \n    subplot(1,2,1); \n    imshow(gray_img);\n    title('Grayscale Image');\n    subplot(1,2,2);\n    imshow(binary_img);\n    title('Binarized Image');\n</code></pre> Try to find a suitable threshold to minimize the variances within the foreground and background, while maximize the variance between them. \\(N_{Fgrd}\\): the number of pixels in the foreground \\(N_{Bgrd}\\): the number of pixels in the background \\(\\sigma_{Fgrd}^2\\): the variance of the foreground \\(\\sigma_{Bgrd}^2\\): the variance of the background \\(\\sigma_{within}^2\\): the variance within the foreground and background \\(\\mu_{Fgrd}\\): the mean of the foreground \\(\\mu_{Bgrd}\\): the mean of the background Simplified formula: \\(\\sigma_{between}=w_b*w_f*(\\mu_{Fgrd}-\\mu_{Bgrd})^2\\) (use findmax loop to find the maximum value of \\(\\sigma_{between}\\)) Otsu's method: embedded in matlab  Matlab<pre><code>    threshold=graythresh(gray_img);\n    binary_img=imbinarize(gray_img,threshold);\n</code></pre> </p> <p>Tip</p> <p>Numerical Analysis can bew imoplemented to find the optimal threshold </p>"},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_Two/#generalization","title":"Generalization","text":""},{"location":"ZJU%20CS%20COURSES/DIGITAL%20IMAGE%20PROCESSING/Chapter_Two/#webers-law","title":"Weber's law","text":"<ul> <li>Weber's law:   <p>\\(\\frac{\\Delta I}{I}=k\\) \\(\\Delta I\\): the smallest difference that can be perceived by human eyes \\(I\\): the intensity of the light \\(k\\): constant, between 0.01 and 0.02  </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/","title":"Numerical Analysis","text":"<p>Note</p> <p>caluculate in computers, interesting course, given by Prof. Ruofeng Tong</p>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Five/","title":"Initial-Value Problems for Ordinary Differential Equations","text":""},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Five/#51-the-elementary-theory-of-initial-value-problems","title":"5.1 The Elementary Theory of Initial-Value Problems","text":"<p>A few basic theories for normal differential equations</p> Lipschitz ComstantConvexLipschitz ConditionFundamental Theorem of Existence and Uniqueness <p>A function \\(f(x,y)\\) is said to satisfy a Lipschitz condition in the variable \\(y\\) on a set \\(D\\) in the \\(xy\\)-plane if there exists a constant \\(L&gt;0\\) such that \\(\\(|f(x,y_1)-f(x,y_2)|\\leq L|y_1-y_2|\\)\\) for all \\((x,y_1),(x,y_2)\\in D\\). </p> <p> </p> <p> </p> <p> </p> <ul> <li>Well-Posed Problems </li> </ul> <p>Note</p> <p> </p> <p>The problem specified by (5.3) is called a perturbed problem associated with the original problem (5.2). It assumes the possibility of an error being introduced in the statement of the differential equation, as well as an error \\(\\sigma_0\\) being present in the initial condition.   </p> <p>Tip</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Five/#52-the-euler-method","title":"5.2 The Euler Method","text":"<ul> <li>Quite simple and easy to implement, set foundations for advanced and sophiscticated methods  </li> <li>Based on Taylor series expansion   <p>Suppose each step size is \\(h\\), then the discrete points of \\(y\\) can be aproxiamted by the following formula: \\(w_i+1=w_i+hf(x_i,w_i)\\)-&gt;which is called the difference equation of the Euler method \\(w_0=y_0=\\alpha\\) </p> </li> </ul> seoducodedemonstration <p>seoducode</p> <p> </p> <p>demonstration</p> <p> </p> <ul> <li>It's easy to identify that error grows slightly as the value of the input \\(t\\) increases. Thanks to Euler method's simplicity and  stability, the error growth is controlled under a linear level.</li> </ul>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Five/#error-bounds-for-eulers-method","title":"Error Bounds for Euler's Method","text":"<ul> <li>Although Euler\u2019s method is not accurate enough to warrant its use in practice, it is sufficiently elementary to analyze the error that is produced from its application.   </li> </ul> <p>Computational Lemmas</p> Lemma 5.7Lemma 5.8Theorem 5.9 <p> </p> <p> </p> <p> </p> <ul> <li> <p>Have to mention that the requirement of the second deriative of \\(f\\) is the weakness, but \\(\\frac{\\partial f}{\\partial t}(t,u(t))+\\frac{\\partial f}{\\partial y}(t,y(t))\\cdot f(t,y(t))\\), therefore its possible to obtain an error bound without explicitly knowing \\(y(t)\\) </p> <p>Please bear in  mind that the error bound is linear to the step size \\(h\\), therefore diminishing the step size can help to reduce the error.    </p> </li> <li> <p>However, round-off error plays in step size choosing. When we are operating Euler method on computers, we are unintentionally using the following formula to iterate: \\(u_0=\\alpha+\\sigma_0, u_{i+1}=u_i+hf(t_i,u_i)+\\sigma_{i+1}\\), where \\(\\sigma_{i}\\) is the round-off error.    </p> </li> </ul> <p>The sufficient theory for rounding errors</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Three/","title":"Interpolation","text":""},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Three/#31-interpolation-and-the-lagrange-polynomial","title":"3.1 Interpolation and the Lagrange Polynomial","text":"<p>One of the most useful classes of functions mapping the st of real numbers into itself is algebraic polynomials. \\(P_n(x) = a_0 + a_1x + a_2x^2 + \\cdots + a_nx^n\\)  One reason for their importance is that they uniformly approximate continuous functions. Theorem 3.1: (Weiertrass Approximation Theorem Let \\(f\\) be a continuous function on the interval \\([a, b]\\). Then, for every \\(\\epsilon &gt; 0\\), there exists a polynomial \\(P(x)\\) such that  \\(|f(x) - P(x)| &lt; \\epsilon\\), for all \\(x \\in [a, b]\\). the derivative and indefinite integral of a polynomial are easy to determine </p> <p>The difference between polynomial interpolation and the Taylor polynomials</p> <p>The Taylor polynomials agree as closely as possible with a given function at a specific point, but they concentrate their accuracy near that point. A good interpolation polynomial needs to provide a relatively accurate approximation over an entire interval </p> <p>Lagrange Interpolating Polynomial * Polynomial interpolation definition:  The problem of determining a polynomial of degree one that passes through the distinct points (x0, y0) and (x1, y1) is the same as approximating a function f for which f (x0) = y0 and f (x1) = y1 by means of a first-degree polynomial interpolating, or agreeing with, the values of f at the given points. Using this polynomial for approximation within the interval given by the endpoints is called polynomial interpolation.    </p> <ul> <li>The n th Lagrange interpolating polynomial is defined as:  Theorem 3.2: (Lagrange Interpolating Polynomial) Given n + 1 distinct points \\((x_0, y_0), (x_1, y_1), \\cdots, (x_n, y_n)\\), there exists a unique polynomial \\(P_n(x)\\) of degree at most n that passes through these points. This polynomial is given by  \\(\\(P_n(x) = y_0L_0(x) + y_1L_1(x) + \\cdots + y_nL_n(x)\\)\\) where the Lagrange basis functions \\(L_k(x)\\) are defined by   \\(\\(L_k(x) = \\frac{(x - x_0)(x - x_1)\\cdots(x - x_{k-1})(x - x_{k+1})\\cdots(x - x_n)}{(x_k - x_0)(x_k - x_1)\\cdots(x_k - x_{k-1})(x_k - x_{k+1})\\cdots(x_k - x_n)}\\)\\) </li> </ul>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Three/#33-divided-difference","title":"3.3 Divided Difference","text":"<p>Divided Difference \\(P_n(x)=a_0+a_1(x-x_0)+a_2(x-x_0)(x-x_1)+\\cdots+a_n(x-x_0)(x-x_1)\\cdots(x-x_{n-1})\\) the main purpose is to calulate the coefficients \\(a_0, a_1, \\cdots, a_n\\) recursively Theorem 3.3: (Divided Difference) Given n + 1 distinct points \\((x_0, y_0), (x_1, y_1), \\cdots, (x_n, y_n)\\), the divided difference \\(f[x_0, x_1, \\cdots, x_k]\\) is defined by \\(\\(f[x_0, x_1, \\cdots, x_k] = \\frac{f[x_1, x_2, \\cdots, x_k] - f[x_0, x_1, \\cdots, x_{k-1}]}{x_k - x_0}\\)\\) with \\(f[x_i] = y_i\\) for \\(i = 0, 1, \\cdots, n\\). therefore, the interpolating polynomial can be written as: \\(\\(P_n(x) = f[x_0] + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + \\cdots + f[x_0, x_1, \\cdots, x_n](x - x_0)(x - x_1)\\cdots(x - x_{n-1})\\)\\) Newton's Divided Difference Interpolating Polynomial </p> <p>INPUT numbers \\(x_0,x_1,\\cdots,x_n\\) and values \\(f(x_0),f(x_1),\\cdots,f(x_n)\\) as \\(F_{0,0},F_{1,0},\\cdots,F_{n,0}\\) OUTPUT the numbers of \\(F_{0,0}, F_{1,1}, \\cdots, F_{n,n}\\) where \\(P_n(x)=F_{0,0}+\\sum_{i=1}^{n}F_{i,i}\\prod_{j=0}^{i-1}(x-x_j)\\) for \\(i=1,2,\\cdots,n\\) do     for \\(j=0,1,\\cdots,i\\) do \\(F_{i,j}=\\frac{F_{i,j}-F_{i-1,j-1}}{x_i-x_{i-j}}\\) return \\(F_{0,0},F_{1,1},\\cdots,F_{n,n}\\) </p> <p>Theorem 3.6: (Newton's Divided Difference Interpolating Polynomial) </p> <p>Note</p> <p> </p> <p>Newton forward-difference formula Newton backward-difference formula </p> Tip <p>when we need to calculate a value of \\(f(x)\\) at a point \\(x\\) that is not in the table, we choose the Newton forward-difference formula or the Newton backward-difference formula by calculating whether the difference between \\(x\\) and the first point in the table is smaller or larger than the difference between \\(x\\) and the last point in the table. because s is relatively smaller, hence the amount of error can be relatively reduced when multiplying  </p> <p>Centered difference </p>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Three/#34-hermite-interpolation","title":"3.4 Hermite Interpolation","text":"<p>Hermite Interpolating Polynomial </p>"},{"location":"ZJU%20CS%20COURSES/NUMERICAL%20ANALYSIS/Chapter_Three/#35-cubic-spline-interpolation","title":"3.5 Cubic Spline Interpolation","text":"<p>Natural Splines If f is defined at a = x0 &lt; x1 &lt; \u00b7\u00b7\u00b7 &lt; xn = b, then f has a unique natural spline interpolant S on the nodes x0, x1, ..., xn; that is, a spline interpolant that satisfies the natural boundary conditions \\(S''(a)\\) and \\(S''(b)\\) = 0.  </p> <p>Note</p> <p>\\(h_{j-1}c_{j-1}+2(h_{j-1}+h_j)c_j+h_jc_{j+1}=3\\left(\\frac{f(x_{j+1})-f(x_j)}{h_j}-\\frac{f(x_j)-f(x_{j-1})}{h_{j-1}}\\right)\\) </p> <p> </p> <p>Seoducode</p> <p> </p> <p>Clamped Splines </p> <p>seoducode</p> <p> </p>"},{"location":"ZJU%20CS%20COURSES/OOP/","title":"Index","text":""},{"location":"ZJU%20CS%20COURSES/OOP/#object-oriented-programming","title":"Object Oriented Programming","text":"<p>Note</p> <p>This course is given by Prof. Kai Weng, one of the best teachers of foundimental programming courses in ZJU. </p>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/","title":"Class Four","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#class-four","title":"Class Four","text":"<ul> <li>destructor   </li> </ul> C++<pre><code>struct point  \n{ \n    int x, y;  \n    point(int x, int y) : x(x), y(y) {}  \n    ~point() { cout &lt;&lt; \"destructor\" &lt;&lt; endl; }  \n}  \n</code></pre> <ul> <li> <p>the call of the destructor is automatic, thus the latter object created will be destroyed first.    </p> </li> <li> <p>living life span of a local object: from the beginning of the block to the end of the block.   </p> </li> <li> <p><code>goto</code>: jump to the label, which is a bad practice.   </p> </li> <li> <p>aggregate initialization with Ctor </p> </li> <li>use {} to initialize the object.   </li> </ul> <p>C++<pre><code>point p1 = {1, 2};  \n</code></pre> if there is a initialization funtion we should use the initialization function to initialize the object.   </p> C++<pre><code>point p1[]={point(1, 2), point(3, 4)};  \n</code></pre>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#inside-object","title":"inside Object","text":"<ul> <li> <p>A program is a bounch of objects telling each other what to do by sending messages.----Alan Kay  </p> </li> <li> <p>access control </p> </li> </ul> <ul> <li> <p>public: can be accessed by any function.    </p> </li> <li> <p>private: can only be accessed by the member functions of the class.  </p> <ul> <li>b.j is illegal if b is an object of class B and j is a private member of class B.</li> </ul> </li> <li>if no access control is specified, the default is public (struct) </li> </ul> <p>Tip</p> <p>Different objects of the same class, their private members can be accessed by each other. </p> <ul> <li>Friend:      </li> </ul> <ul> <li>a friend function can access the private members of the class. C++<pre><code>class A  \n{  \n    friend void f();  \n};  \n</code></pre></li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#class","title":"Class","text":"<ul> <li>the difference between class and struct is the default access control.  </li> <li>the default access control of class is private.  </li> <li>the default access control of struct is public.    </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#where-are-the-objects","title":"Where are the objects?","text":"<ul> <li>Fields, parameter, local variables  </li> <li>global variable  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#static-initialization-dependency","title":"Static Initialization Dependency","text":"<ul> <li>Order between files is unspecified  </li> <li>the tendency is not to use any global variables.  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#static","title":"Static","text":"<ul> <li>two basic meanings:   <p>static storage   restricted access    </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Four/#the-use-of-static-in-c","title":"the use of \"static\" in C++","text":"<ul> <li>static applied to objects   </li> </ul> <p>create when called, destroyed when the program ends.  </p> <ul> <li>Can we apply static to members?   </li> </ul> <p>static member: shared by all objects of the class, thus not belongs to any object therefore, a definition of the static member is necessary. <code>int StatMem::m_h;</code> static funtion: </p>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_One/","title":"Class One","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Class_One/#intro","title":"Intro","text":"<ul> <li> <p>Buzzword  </p> <p>encapsulation  \u5c01\u88c5 inheritance \u7ee7\u627f polymorphism \u591a\u6001 overriding \u8986\u76d6 interface \u63a5\u53e3 cohesion \u5185\u805a coupling \u8026\u5408 collection classes \u5bb9\u5668\u7c7b template \u6a21\u677f responsibility-driven design \u8d23\u4efb\u9a71\u52a8\u8bbe\u8ba1   </p> </li> <li> <p>Book reference: Thinking in C++    </p> </li> <li> <p>The C language  </p> <p>Efficient programs direct access to machine flexible   </p> </li> <li> <p>C++ improvements  </p> <p>data abstraction access control initialization &amp; cleanup function overloading stream for I/O    </p> </li> <li> <p>The first program  C++<pre><code>    #include &lt;iostream&gt;  \n    using namespace std;  \n    int main()  \n    {\n        cout &lt;&lt; \"Hello, World!\"&lt;&lt; endl;  \n\n    }  \n</code></pre></p> </li> <li>iostream is a header file name without a .h suffix. iostream.h happens to exist, yet it is an outdated version  </li> <li><code>&lt;&lt;</code>: inserter  </li> <li><code>cin &gt;&gt; variable</code>: extractor    </li> <li>use <code>;</code> to connnect the shell commands  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_One/#format-output","title":"Format output","text":"<ul> <li><code>#include &lt;iomanip&gt;</code>: manipulators are special functions that can be included in the I/O statement to alter the format parameters of a stream.  </li> <li><code>endl</code> is one of them  </li> <li><code>setw(int width)</code>: set the output width  </li> <li><code>setprecision(int n)</code>: set the number of digits in decimal parts </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_One/#string","title":"String","text":"<ul> <li><code>#include &lt;string&gt;</code>: c don't have a string type   </li> <li><code>string str</code>: a string  </li> <li><code>str=\"Hello\"</code> , <code>str(\"Hello\")</code>, <code>s3{\"see see\"}</code> for every type, yet when it comes to the third way of initialization, one should add <code>g++ -std=c++11</code> when compiling.  </li> <li>objects can transfer contents through <code>=</code> </li> <li><code>cin</code>: only read the first word  </li> <li><code>getline(cin, str)</code>: read the whole line    </li> <li><code>string s[0]</code>: the first character of the string, the same as the array in c    </li> <li><code>string s2=string s1+ string s3</code>: string concatenation  </li> <li><code>s2.length()</code>: the length of the string  </li> <li><code>s2(s3,2,3)</code>: the third to the fifth character of s3, <code>2</code> is the starting position, <code>3</code> is the length of the substring    </li> <li><code>s2.substr(2,3)</code>: the same as above    </li> <li><code>insert(size_t pos, const string&amp; str)</code>: insert a string into another string  </li> <li><code>erase(size_t pos, size_t len)</code>: erase a substring  </li> <li><code>replace(size_t pos, size_t len, const string&amp; str)</code>: replace a substring with another string  </li> <li><code>find(const string&amp; str, size_t pos=0)</code>: find the first occurrence of a substring  </li> <li><code>append(const string&amp; str)</code>: append a string to another string     </li> <li><code>string *p=&amp;s</code>: a pointer to a string  </li> <li><code>s-&gt;length()</code>: the length of the string, the same as <code>(*s).length()</code> </li> <li><code>string s1, s2; s1=s2;</code>: copy the string, two different objects  </li> <li><code>string *p=&amp;s1; string *q=&amp;s2; p=q;</code>: two pointers point to the same object <code>s2</code> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Ten/","title":"Class Ten","text":"<ul> <li> <p>vptr: \u5728\u6784\u9020\u51fd\u6570\u4e2d\u8d4b\u503c\uff0c\u5176\u4ed6\u60c5\u51b5\u4e0b\u65e0\u6cd5\u8d4b\u503c</p> </li> <li> <p>copy\u65f6\uff0c class\u9690\u542b\u4e00\u4e2acopy\u6784\u9020\u51fd\u6570\uff0c\u8fd9\u4e2acopy\u6784\u9020\u51fd\u6570\u662f\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u81ea\u5df1\u5b9a\u4e49\u4e86\u4e00\u4e2acopy\u6784\u9020\u51fd\u6570\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u5c31\u4e0d\u4f1a\u518d\u751f\u6210\u4e00\u4e2a\u4e86</p> </li> <li> <p>\u5982\u679c\u51fd\u6570\u662f\u5728 return value \u4e2d\u521b\u5efa\uff0c\u90a3\u4e48\u4ece local copy \u81f3\u4e34\u65f6return value \u8fd9\u4e00\u6bb5 copy \u5c31\u53ef\u4ee5\u88ab\u7f16\u8bd1\u5668\u7701\u7565\uff0c\u5982\uff1a C++<pre><code>Person copy_\n\nfunc( char *who ) {\n\nPerson local( who );\n\nlocal.print();\n\nreturn local; // copy ctor called!\n\n}\n\nPerson nocopy_\n\nfunc( char *who ) {\n\nreturn Person( who );\n\n} // no copy needed!\n</code></pre></p> </li> <li> <p>Construction vs assignment:</p> <p>every object construct once  be destroyed once  once constructed, can be assigned multiple times</p> </li> </ul> <p>[!abstract] tips * Pass in an object if you want to store it, * Pass in a const pointer or reference if you * want to get the values * Pass in a pointer or reference if you * want to do something to it * Pass out an object if you create it in the function * Pass out pointer or reference of the passed in only * Never new something and return the pointer</p> <ul> <li> <p>\u79fb\u52a8\u6784\u9020\u51fd\u6570</p> <p>Moveable c(move(a)); \u8fd9\u6837\u7684\u8bed\u53e5\u3002\u8fd9\u91cc\u7684 a \u672c\u6765\u662f\u4e00\u4e2a\u5de6\u503c\u53d8\u91cf\uff0c\u901a\u8fc7std:: move \u5c06\u5176\u8f6c\u6362\u4e3a\u53f3\u503c\u3002\u8fd9\u6837\u4e00\u6765\uff0c a.i \u5c31c \u7684\u79fb\u52a8\u88ab\u6784\u9020\u51fd\u6570\u8bbe\u7f6e\u4e3a\u6307\u9488\u7a7a\u503c\u3002\u7531\u4e8e a \u7684\u751f\u547d\u671f\u5b9e\u9645\u8981\u5230\u6240\u5728\u7684\u51fd\u6570\u7ed3\u675f\u624d\u7ed3\u675f\uff0c\u90a3\u4e48\u968f\u540e\u5bf9\u8868\u8fbe\u5f0f <code>*a.i</code> \u8fdb\u884c\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u53d1\u751f\u4e25\u91cd\u7684\u8fd0\u884c\u65f6\u9519\u8bef</p> </li> <li></li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/","title":"Class Three","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#preclass-quiz","title":"Preclass Quiz","text":"<ul> <li>after deleting ls.erase(it), 'it' will return the next element  </li> <li><code>vector&lt;int&gt;::iterator it=ls.end();</code>: returns an iterator pointing to the past-the-end element in the list container.  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#defining-class","title":"Defining Class","text":"<ul> <li> <p>Point  </p> <p>Pointer transmit is more efficient than passing the whole structure.    </p> </li> <li> <p>Why all these functions need to pass the point structure pointer?  </p> <p>to make the function be more universally used, that is , dealing with all kinds of point structures.  </p> </li> <li> <p>Migrate to C++  </p> <p>move the function to the class, and make it a member function. '''cpp  </p> </li> </ul> <p>struct Point {     int x;     int y;     void setX(int x);     void setY(int y);     int getX();     int getY();     void print(); };   void Point::setX(int x) {     this-&gt;x=x; }  </p> <p>'''   '''cpp  void S::f(){     ::f(); //call the global function f      ::a++; //access the global variable a  } '''   * the fetching critiria of the member function    </p> <p>this pointer: a pointer to the object that the member function is called on. p.prt(); //Point::prt(&amp;p); the local variable will override the outer variable </p>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#object","title":"Object","text":"<ul> <li>Object: an instance of a class , attributes + service , data+operation    <p>encapsulation: data hiding  </p> </li> <li> <p>object oriented programming:  </p> <p>models designed can be used in multi-circumstances. rather, procedural programming is more like a one-time use.  </p> </li> <li> <p>UML: Unified Modeling Language  </p> </li> <li> <p>class is mostly the same with struct in cpp, but mostly...  </p> </li> <li> <p>Every object has a type  </p> </li> <li> <p>.h: header file, to be portable, the body of the class should be in the .cpp file, which are hidden from the user.  Bear in mind the basic pinciple of encapsulation </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#declaration-and-definition","title":"Declaration and Definition","text":"<ul> <li>a .cpp file is a compile unit  </li> <li>Declaration:   <p>tells the compiler that the class exists, but not the details.  </p> </li> <li> <p>Definition:  </p> <p>tells the compiler the details of the class.  </p> </li> <li> <p>the difference between &lt;&gt; and \"\" in the include statement:  </p> <p>&lt;&gt;: search the system path, INCLUDE(environment variable), -I, \"\": search the current path, prior to the system path, then being similar to the &lt;&gt; open source libraries: put the opensource library in a particular path, and add the path to the INCLUDE environment variable.  </p> </li> <li> <p>Standard header files:   '''cpp</p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#ifndef-_point_h","title":"ifndef _POINT_H","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#define-_point_h","title":"define _POINT_H","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Class_Three/#endif","title":"endif","text":"<p>'''  </p> <ul> <li> <p>What if not initializing the object?  </p> <p>no specific value  </p> </li> <li> <p>init : not safe enough  </p> </li> <li>constructor:   <p>Point(): default constructor(without a parameter) , no return  '''cpp  </p> </li> </ul> <p>class Point    {        int x;        int y;        Point(int x=0, int y=0);    };    Point p(1,2);      </p> <p>'''       * initializer list  </p> <p>Point(int xx=0, int yy=0):x(xx),y(yy){}  the last is the inner constructer function to do initialization.  </p>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Two/","title":"Class Two","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Class_Two/#containers","title":"Containers","text":"<ul> <li>Also Known As: Collection   </li> <li>STL: Standard Template Library  </li> <li>Reduce development time and increase efficiency   <p>Data-structures are already written and debugged    </p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Two/#why-stl","title":"Why STL?","text":"<ul> <li>Code readability  </li> <li>Robustness  </li> <li>Portable, maintainable, and easy  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Two/#c-standard-library","title":"C++ Standard Library","text":"<ul> <li>a pair class:  C++<pre><code>#include &lt;utility&gt;  \npair&lt;int, int&gt; p;  \np.first=1;  \np.second=2;  \n</code></pre></li> <li> <p>Containers:  </p> <ul> <li>vector C++<pre><code>#include &lt;vector&gt;  \nvector&lt;int&gt; v;  \nv.push_back(1);  \nv.push_back(2);  \n</code></pre></li> <li>deque: double-ended queue  C++<pre><code>#include &lt;deque&gt;  \ndeque&lt;int&gt; d;  \nd.push_back(1);  \nd.push_front(2);  \n</code></pre></li> <li>list: doubly linked list C++<pre><code>#include &lt;list&gt;  \nlist&lt;int&gt; l;  \nl.push_back(1);  \nl.push_front(2);  \n</code></pre></li> <li>set: C++<pre><code>#include &lt;set&gt;  \nset&lt;int&gt; s;  \ns.insert(1);  \ns.insert(2);  \n</code></pre></li> <li>map: dictionary  C++<pre><code>#include &lt;map&gt;  \nmap&lt;int, string&gt; m;  \nm[1]=\"one\";  \nm[2]=\"two\";  \n</code></pre></li> </ul> </li> <li> <p>Basic Algorithms, sort, search  </p> </li> <li>all identifiers are in the std namespace  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Two/#examples","title":"Examples","text":"<ul> <li> <p>vector C++<pre><code>    #include &lt;iostream&gt;  \n    #include &lt;string&gt;    \n    #include &lt;vector&gt;//every type of container should include the corresponding header file\n    using namespace std;  \n    int main()\n    {\n        vector&lt;int&gt; v;  \n        for(int i=0; i&lt;10; i++)\n        {\n            v.push_back(i);//add elements to the end of the vector\n        }  \n        cout &lt;&lt; v.size() &lt;&lt; endl;  \n        cout &lt;&lt; v.capacity() &lt;&lt; endl;  \n        for(int i=0; i&lt;v.size(); i++)\n        {\n            cout &lt;&lt; v[i] &lt;&lt; \" \";    \n            cout &lt;&lt; v.at(i) &lt;&lt; endl;\n        }  \n        vector&lt;int&gt;::iterator it;  \n        for(it=v.begin(); it!=v.end(); it++)\n        {\n            cout &lt;&lt; *it &lt;&lt; \" \";  \n        }\n    }  \n</code></pre></p> </li> <li> <p>Generic Classes:  </p> <p><code>vector&lt;int&gt; v</code>; <code>vector&lt;string&gt; notes</code> Have to specify two types: the type of the collection itself and the type of the elements that we plan to store in the collection  </p> </li> <li> <p>Constructors:    </p> </li> <li> <p><code>vector&lt;int&gt; v; vector&lt;int&gt; v1(v)</code>: two vectors, <code>v1</code> is a copy of <code>v</code> </p> </li> <li> <p>Simple Methods:  </p> <p><code>v.size()</code>: number of items <code>v.empty()</code>: whether the vector is empty   <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> <code>v.swap(v1)</code>: swap the contents of two vectors  </p> </li> <li> <p>iterators:  </p> <p><code>vector&lt;int&gt;::iterator it</code> <code>it=v.begin()</code>: iterator of the first position <code>it=v.end()</code>: iterator of the last position    </p> </li> <li> <p>Element Access:  </p> <p><code>v.at(index)</code> <code>v[index]</code> <code>v.front()</code>, <code>v.back()</code> </p> </li> <li> <p>Add/Remove/Find:  </p> <p><code>v.push_back(e)</code> <code>v.pop_back()</code> <code>v.insert(pos,e)</code> <code>v.erase(pos)</code> <code>v.clear()</code> <code>v.find(first, last, item)</code> </p> </li> <li> <p>Preallocate Memory: C++<pre><code>   vector&lt;int&gt; v(100); //capacity is 100 \n   v[80]=1;    \n   cout&lt;&lt;v[100]&lt;&lt;endl;//might not have a problem, sometimes the vector class add some extra capacity when preallocation \n</code></pre></p> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Class_Two/#list","title":"List","text":"<ul> <li>same basic concepts as vector, but double linked list </li> <li><code>list&lt;int&gt; l;</code> </li> <li><code>l.push_back(e)</code>, <code>l.push_front(e)</code> </li> <li><code>l.pop_back()</code>, <code>l.pop_front()</code> </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Make/","title":"Make","text":""},{"location":"ZJU%20CS%20COURSES/OOP/Make/#how-to-write-a-makefile","title":"How to write a Makefile","text":"<ul> <li> <p>sum: objective + main.o+ sum.o  </p> </li> <li> <p>gcc main.o sum.o -o sum     </p> </li> <li> <p>main.o: main.c  sum.h   </p> <p>gcc -c main.c //-c only compile without linking </p> </li> </ul> <p>sum.o: sum.c sum.h  </p> Text Only<pre><code>gcc -c sum.c\n</code></pre> <ul> <li> <p>make file only compiles necessary files.  </p> </li> <li> <p>a simpler version Makefile<pre><code>sum: main.o sum.o  \n    gcc main.o sum.o -o sum  \nmain.o:sum.h  \nsum.o=sum.h  \n%.o:%.c  \n    gcc -c $&lt;  //universally compile all .c files\n</code></pre></p> </li> <li><code>$&lt;</code> is the first prerequisite, $ is variable.  Makefile<pre><code>OBJS=main.o sum.o  \nsum: $(OBJS)  \n    gcc $(OBJS) -o sum  \n$(OBJS): sum.h  \n%.o:%.c  \n    gcc -c $&lt;  \n</code></pre> Makefile<pre><code>OBJS=main.o sum.o  \nsum: $(OBJS) \n    @echo \"Linking $^ to $@\" //@ not to show echo \n    gcc $^ -o $@// $@ is the target file, $^ is the prerequisites.\n$(OBJS): sum.h\n%.o:%.c    \n\n    gcc -c $&lt;  \n</code></pre> Makefile<pre><code>clean:  \n    rm -f sum $(OBJS)  \n</code></pre></li> <li><code>make clean</code> to clean the files.  </li> <li><code>-Wall</code> to show all warnings.  </li> </ul>"},{"location":"ZJU%20CS%20COURSES/OOP/Make/#fake-targets","title":"fake targets","text":"<ul> <li>'clean' is a fake target. </li> <li>make will find the first target to compile  </li> </ul> Makefile<pre><code>OBJS=main.o sum.o\nall: sum\nsum: $(OBJS)\n    gcc $^ -o $@\n$(OBJS): sum.h\n%.o:%.c\n    gcc -c $&lt;\nclean:\n    rm -f sum $(OBJS)\n</code></pre> <ul> <li>the '%.h' file can be omitted, but to make the '.h' program recompile when changed, it is necessary to add the '.h' file.</li> <li>run the program by <code>make</code> is also feasible.   </li> <li><code>$ARGS$</code>: make ARGS=\"1 2 3\" can do input    </li> <li>\u901a\u8fc7\u5b8f\u6539\u53d8\u7a0b\u5e8f\u4e2d\u53c2\u6570    </li> <li>'-MMD' in gcc, to generate the dependency file automatically, generate the '.d' file, with dependencies inside it  </li> <li>'-include DEPS=$(OBJS:.o=.d)' to include the '.d' file    </li> </ul>"},{"location":"self_learning/","title":"Self Learning Section","text":"<p>Note</p> <p>Computer Science is a fascinating field, in which there are a lot to learn. This section contains notes of the self-learnt courses, mostly are online, open-sourse courses from prestigious universities around the world, and I'm so grateful for the generosity of the universities and the professors who are willing the share their knowledge with everyone devoted to learn cs.</p>"}]}